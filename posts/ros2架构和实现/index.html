<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ROS2架构和实现 | Jerry Wang</title>
<meta name=keywords content="ROS2"><meta name=description content="ROS2是机器人领域的著名SDK，可以加速学习效率。ROS2主要解决了两个问题：

通信：基于Node，包含topic、service、action通信方式
代码架构：模块化开发，简化维护

一、架构
userland: code
client: rclc rclcpp rclpy etc&mldr;
abstract: rcl
middleware: rmw rmw_implementation rmw_fastrtps etc &mldr;
dds: fastdds Context_RTI etc&mldr;
二、实现
ROS2代码惯例：
./
../
include/... # 头文件
src/...     # 实现
1、Node实现
推荐继承Node实现业务功能, 主要选择合理的通信方式，注册回调函数。
namespace palomino
{
    class VincentDriver : public rclcpp::Node
    {
        // ...
    };
}

int main(int argc, char * argv[])
{
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<palomino::VincentDriver>());
    rclcpp::shutdown();
    return 0;
}
Node的声明：

// node.hpp

class Node : public std::enable_shared_from_this<Node>
{
public:
  explicit Node(
    const std::string & node_name,
    const NodeOptions & options = NodeOptions());

  explicit Node(
    const std::string & node_name,
    const std::string & namespace_,
    const NodeOptions & options = NodeOptions());

  virtual ~Node();

  // 创建发布者
  template<
    typename MessageT,
    typename AllocatorT = std::allocator<void>,
    typename PublisherT = rclcpp::Publisher<MessageT, AllocatorT>>
  std::shared_ptr<PublisherT>
  create_publisher(
    const std::string & topic_name,
    const rclcpp::QoS & qos,
    const PublisherOptionsWithAllocator<AllocatorT> & options =
    PublisherOptionsWithAllocator<AllocatorT>()
  );
  
  // 创建订阅者
  template<
    typename MessageT,
    typename CallbackT,
    typename AllocatorT = std::allocator<void>,
    typename SubscriptionT = rclcpp::Subscription<MessageT, AllocatorT>,
    typename MessageMemoryStrategyT = typename SubscriptionT::MessageMemoryStrategyType
  >
  std::shared_ptr<SubscriptionT>
  create_subscription(
    const std::string & topic_name,
    const rclcpp::QoS & qos,
    CallbackT && callback,
    const SubscriptionOptionsWithAllocator<AllocatorT> & options =
    SubscriptionOptionsWithAllocator<AllocatorT>(),
    typename MessageMemoryStrategyT::SharedPtr msg_mem_strat = (
      MessageMemoryStrategyT::create_default()
    )
  );

  // 创建service的客户端
  template<typename ServiceT>
  typename rclcpp::Client<ServiceT>::SharedPtr
  create_client(
    const std::string & service_name,
    const rclcpp::QoS & qos = rclcpp::ServicesQoS(),
    rclcpp::CallbackGroup::SharedPtr group = nullptr);

  // 创建service的服务端
  template<typename ServiceT, typename CallbackT>
  typename rclcpp::Service<ServiceT>::SharedPtr
  create_service(
    const std::string & service_name,
    CallbackT && callback,
    const rclcpp::QoS & qos = rclcpp::ServicesQoS(),
    rclcpp::CallbackGroup::SharedPtr group = nullptr);

  // 参数相关操作方法
  // 其他服务方法

protected:
  Node(
    const Node & other,
    const std::string & sub_namespace);

private:

  rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_base_;
  rclcpp::node_interfaces::NodeGraphInterface::SharedPtr node_graph_;
  rclcpp::node_interfaces::NodeLoggingInterface::SharedPtr node_logging_;
  rclcpp::node_interfaces::NodeTimersInterface::SharedPtr node_timers_;
  rclcpp::node_interfaces::NodeTopicsInterface::SharedPtr node_topics_;
  rclcpp::node_interfaces::NodeServicesInterface::SharedPtr node_services_;
  rclcpp::node_interfaces::NodeClockInterface::SharedPtr node_clock_;
  rclcpp::node_interfaces::NodeParametersInterface::SharedPtr node_parameters_;
  rclcpp::node_interfaces::NodeTimeSourceInterface::SharedPtr node_time_source_;
  rclcpp::node_interfaces::NodeTypeDescriptionsInterface::SharedPtr node_type_descriptions_;
  rclcpp::node_interfaces::NodeWaitablesInterface::SharedPtr node_waitables_;

  const rclcpp::NodeOptions node_options_;
  const std::string sub_namespace_;
  const std::string effective_namespace_;

  class NodeImpl;
  // This member is meant to be a place to backport features into stable distributions,
  // and new features targeting Rolling should not use this.
  // See the comment in node.cpp for more information.
  std::shared_ptr<NodeImpl> hidden_impl_{nullptr};
};
2、启动
上面的代码示例中，main函数调用了三个ROS2 C++客户端库的函数："><meta name=author content="Jerry Wang"><link rel=canonical href=https://solaim.github.io/posts/ros2%E6%9E%B6%E6%9E%84%E5%92%8C%E5%AE%9E%E7%8E%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://solaim.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://solaim.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://solaim.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://solaim.github.io/apple-touch-icon.png><link rel=mask-icon href=https://solaim.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://solaim.github.io/posts/ros2%E6%9E%B6%E6%9E%84%E5%92%8C%E5%AE%9E%E7%8E%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://solaim.github.io/posts/ros2%E6%9E%B6%E6%9E%84%E5%92%8C%E5%AE%9E%E7%8E%B0/"><meta property="og:site_name" content="Jerry Wang"><meta property="og:title" content="ROS2架构和实现"><meta property="og:description" content="ROS2是机器人领域的著名SDK，可以加速学习效率。ROS2主要解决了两个问题：
通信：基于Node，包含topic、service、action通信方式 代码架构：模块化开发，简化维护 一、架构 userland: code
client: rclc rclcpp rclpy etc…
abstract: rcl
middleware: rmw rmw_implementation rmw_fastrtps etc …
dds: fastdds Context_RTI etc…
二、实现 ROS2代码惯例：
./ ../ include/... # 头文件 src/... # 实现 1、Node实现 推荐继承Node实现业务功能, 主要选择合理的通信方式，注册回调函数。
namespace palomino { class VincentDriver : public rclcpp::Node { // ... }; } int main(int argc, char * argv[]) { rclcpp::init(argc, argv); rclcpp::spin(std::make_shared<palomino::VincentDriver>()); rclcpp::shutdown(); return 0; } Node的声明：
// node.hpp class Node : public std::enable_shared_from_this<Node> { public: explicit Node( const std::string & node_name, const NodeOptions & options = NodeOptions()); explicit Node( const std::string & node_name, const std::string & namespace_, const NodeOptions & options = NodeOptions()); virtual ~Node(); // 创建发布者 template< typename MessageT, typename AllocatorT = std::allocator<void>, typename PublisherT = rclcpp::Publisher<MessageT, AllocatorT>> std::shared_ptr<PublisherT> create_publisher( const std::string & topic_name, const rclcpp::QoS & qos, const PublisherOptionsWithAllocator<AllocatorT> & options = PublisherOptionsWithAllocator<AllocatorT>() ); // 创建订阅者 template< typename MessageT, typename CallbackT, typename AllocatorT = std::allocator<void>, typename SubscriptionT = rclcpp::Subscription<MessageT, AllocatorT>, typename MessageMemoryStrategyT = typename SubscriptionT::MessageMemoryStrategyType > std::shared_ptr<SubscriptionT> create_subscription( const std::string & topic_name, const rclcpp::QoS & qos, CallbackT && callback, const SubscriptionOptionsWithAllocator<AllocatorT> & options = SubscriptionOptionsWithAllocator<AllocatorT>(), typename MessageMemoryStrategyT::SharedPtr msg_mem_strat = ( MessageMemoryStrategyT::create_default() ) ); // 创建service的客户端 template<typename ServiceT> typename rclcpp::Client<ServiceT>::SharedPtr create_client( const std::string & service_name, const rclcpp::QoS & qos = rclcpp::ServicesQoS(), rclcpp::CallbackGroup::SharedPtr group = nullptr); // 创建service的服务端 template<typename ServiceT, typename CallbackT> typename rclcpp::Service<ServiceT>::SharedPtr create_service( const std::string & service_name, CallbackT && callback, const rclcpp::QoS & qos = rclcpp::ServicesQoS(), rclcpp::CallbackGroup::SharedPtr group = nullptr); // 参数相关操作方法 // 其他服务方法 protected: Node( const Node & other, const std::string & sub_namespace); private: rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_base_; rclcpp::node_interfaces::NodeGraphInterface::SharedPtr node_graph_; rclcpp::node_interfaces::NodeLoggingInterface::SharedPtr node_logging_; rclcpp::node_interfaces::NodeTimersInterface::SharedPtr node_timers_; rclcpp::node_interfaces::NodeTopicsInterface::SharedPtr node_topics_; rclcpp::node_interfaces::NodeServicesInterface::SharedPtr node_services_; rclcpp::node_interfaces::NodeClockInterface::SharedPtr node_clock_; rclcpp::node_interfaces::NodeParametersInterface::SharedPtr node_parameters_; rclcpp::node_interfaces::NodeTimeSourceInterface::SharedPtr node_time_source_; rclcpp::node_interfaces::NodeTypeDescriptionsInterface::SharedPtr node_type_descriptions_; rclcpp::node_interfaces::NodeWaitablesInterface::SharedPtr node_waitables_; const rclcpp::NodeOptions node_options_; const std::string sub_namespace_; const std::string effective_namespace_; class NodeImpl; // This member is meant to be a place to backport features into stable distributions, // and new features targeting Rolling should not use this. // See the comment in node.cpp for more information. std::shared_ptr<NodeImpl> hidden_impl_{nullptr}; }; 2、启动 上面的代码示例中，main函数调用了三个ROS2 C++客户端库的函数："><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-07T10:20:33+08:00"><meta property="article:modified_time" content="2025-05-07T10:20:33+08:00"><meta property="article:tag" content="ROS2"><meta property="og:image" content="https://solaim.github.io/img/favicon.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://solaim.github.io/img/favicon.webp"><meta name=twitter:title content="ROS2架构和实现"><meta name=twitter:description content="ROS2是机器人领域的著名SDK，可以加速学习效率。ROS2主要解决了两个问题：

通信：基于Node，包含topic、service、action通信方式
代码架构：模块化开发，简化维护

一、架构
userland: code
client: rclc rclcpp rclpy etc&mldr;
abstract: rcl
middleware: rmw rmw_implementation rmw_fastrtps etc &mldr;
dds: fastdds Context_RTI etc&mldr;
二、实现
ROS2代码惯例：
./
../
include/... # 头文件
src/...     # 实现
1、Node实现
推荐继承Node实现业务功能, 主要选择合理的通信方式，注册回调函数。
namespace palomino
{
    class VincentDriver : public rclcpp::Node
    {
        // ...
    };
}

int main(int argc, char * argv[])
{
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<palomino::VincentDriver>());
    rclcpp::shutdown();
    return 0;
}
Node的声明：

// node.hpp

class Node : public std::enable_shared_from_this<Node>
{
public:
  explicit Node(
    const std::string & node_name,
    const NodeOptions & options = NodeOptions());

  explicit Node(
    const std::string & node_name,
    const std::string & namespace_,
    const NodeOptions & options = NodeOptions());

  virtual ~Node();

  // 创建发布者
  template<
    typename MessageT,
    typename AllocatorT = std::allocator<void>,
    typename PublisherT = rclcpp::Publisher<MessageT, AllocatorT>>
  std::shared_ptr<PublisherT>
  create_publisher(
    const std::string & topic_name,
    const rclcpp::QoS & qos,
    const PublisherOptionsWithAllocator<AllocatorT> & options =
    PublisherOptionsWithAllocator<AllocatorT>()
  );
  
  // 创建订阅者
  template<
    typename MessageT,
    typename CallbackT,
    typename AllocatorT = std::allocator<void>,
    typename SubscriptionT = rclcpp::Subscription<MessageT, AllocatorT>,
    typename MessageMemoryStrategyT = typename SubscriptionT::MessageMemoryStrategyType
  >
  std::shared_ptr<SubscriptionT>
  create_subscription(
    const std::string & topic_name,
    const rclcpp::QoS & qos,
    CallbackT && callback,
    const SubscriptionOptionsWithAllocator<AllocatorT> & options =
    SubscriptionOptionsWithAllocator<AllocatorT>(),
    typename MessageMemoryStrategyT::SharedPtr msg_mem_strat = (
      MessageMemoryStrategyT::create_default()
    )
  );

  // 创建service的客户端
  template<typename ServiceT>
  typename rclcpp::Client<ServiceT>::SharedPtr
  create_client(
    const std::string & service_name,
    const rclcpp::QoS & qos = rclcpp::ServicesQoS(),
    rclcpp::CallbackGroup::SharedPtr group = nullptr);

  // 创建service的服务端
  template<typename ServiceT, typename CallbackT>
  typename rclcpp::Service<ServiceT>::SharedPtr
  create_service(
    const std::string & service_name,
    CallbackT && callback,
    const rclcpp::QoS & qos = rclcpp::ServicesQoS(),
    rclcpp::CallbackGroup::SharedPtr group = nullptr);

  // 参数相关操作方法
  // 其他服务方法

protected:
  Node(
    const Node & other,
    const std::string & sub_namespace);

private:

  rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_base_;
  rclcpp::node_interfaces::NodeGraphInterface::SharedPtr node_graph_;
  rclcpp::node_interfaces::NodeLoggingInterface::SharedPtr node_logging_;
  rclcpp::node_interfaces::NodeTimersInterface::SharedPtr node_timers_;
  rclcpp::node_interfaces::NodeTopicsInterface::SharedPtr node_topics_;
  rclcpp::node_interfaces::NodeServicesInterface::SharedPtr node_services_;
  rclcpp::node_interfaces::NodeClockInterface::SharedPtr node_clock_;
  rclcpp::node_interfaces::NodeParametersInterface::SharedPtr node_parameters_;
  rclcpp::node_interfaces::NodeTimeSourceInterface::SharedPtr node_time_source_;
  rclcpp::node_interfaces::NodeTypeDescriptionsInterface::SharedPtr node_type_descriptions_;
  rclcpp::node_interfaces::NodeWaitablesInterface::SharedPtr node_waitables_;

  const rclcpp::NodeOptions node_options_;
  const std::string sub_namespace_;
  const std::string effective_namespace_;

  class NodeImpl;
  // This member is meant to be a place to backport features into stable distributions,
  // and new features targeting Rolling should not use this.
  // See the comment in node.cpp for more information.
  std::shared_ptr<NodeImpl> hidden_impl_{nullptr};
};
2、启动
上面的代码示例中，main函数调用了三个ROS2 C++客户端库的函数："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://solaim.github.io/posts/"},{"@type":"ListItem","position":2,"name":"ROS2架构和实现","item":"https://solaim.github.io/posts/ros2%E6%9E%B6%E6%9E%84%E5%92%8C%E5%AE%9E%E7%8E%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ROS2架构和实现","name":"ROS2架构和实现","description":"ROS2是机器人领域的著名SDK，可以加速学习效率。ROS2主要解决了两个问题：\n通信：基于Node，包含topic、service、action通信方式 代码架构：模块化开发，简化维护 一、架构 userland: code\nclient: rclc rclcpp rclpy etc\u0026hellip;\nabstract: rcl\nmiddleware: rmw rmw_implementation rmw_fastrtps etc \u0026hellip;\ndds: fastdds Context_RTI etc\u0026hellip;\n二、实现 ROS2代码惯例：\n./ ../ include/... # 头文件 src/... # 实现 1、Node实现 推荐继承Node实现业务功能, 主要选择合理的通信方式，注册回调函数。\nnamespace palomino { class VincentDriver : public rclcpp::Node { // ... }; } int main(int argc, char * argv[]) { rclcpp::init(argc, argv); rclcpp::spin(std::make_shared\u0026lt;palomino::VincentDriver\u0026gt;()); rclcpp::shutdown(); return 0; } Node的声明：\n// node.hpp class Node : public std::enable_shared_from_this\u0026lt;Node\u0026gt; { public: explicit Node( const std::string \u0026amp; node_name, const NodeOptions \u0026amp; options = NodeOptions()); explicit Node( const std::string \u0026amp; node_name, const std::string \u0026amp; namespace_, const NodeOptions \u0026amp; options = NodeOptions()); virtual ~Node(); // 创建发布者 template\u0026lt; typename MessageT, typename AllocatorT = std::allocator\u0026lt;void\u0026gt;, typename PublisherT = rclcpp::Publisher\u0026lt;MessageT, AllocatorT\u0026gt;\u0026gt; std::shared_ptr\u0026lt;PublisherT\u0026gt; create_publisher( const std::string \u0026amp; topic_name, const rclcpp::QoS \u0026amp; qos, const PublisherOptionsWithAllocator\u0026lt;AllocatorT\u0026gt; \u0026amp; options = PublisherOptionsWithAllocator\u0026lt;AllocatorT\u0026gt;() ); // 创建订阅者 template\u0026lt; typename MessageT, typename CallbackT, typename AllocatorT = std::allocator\u0026lt;void\u0026gt;, typename SubscriptionT = rclcpp::Subscription\u0026lt;MessageT, AllocatorT\u0026gt;, typename MessageMemoryStrategyT = typename SubscriptionT::MessageMemoryStrategyType \u0026gt; std::shared_ptr\u0026lt;SubscriptionT\u0026gt; create_subscription( const std::string \u0026amp; topic_name, const rclcpp::QoS \u0026amp; qos, CallbackT \u0026amp;\u0026amp; callback, const SubscriptionOptionsWithAllocator\u0026lt;AllocatorT\u0026gt; \u0026amp; options = SubscriptionOptionsWithAllocator\u0026lt;AllocatorT\u0026gt;(), typename MessageMemoryStrategyT::SharedPtr msg_mem_strat = ( MessageMemoryStrategyT::create_default() ) ); // 创建service的客户端 template\u0026lt;typename ServiceT\u0026gt; typename rclcpp::Client\u0026lt;ServiceT\u0026gt;::SharedPtr create_client( const std::string \u0026amp; service_name, const rclcpp::QoS \u0026amp; qos = rclcpp::ServicesQoS(), rclcpp::CallbackGroup::SharedPtr group = nullptr); // 创建service的服务端 template\u0026lt;typename ServiceT, typename CallbackT\u0026gt; typename rclcpp::Service\u0026lt;ServiceT\u0026gt;::SharedPtr create_service( const std::string \u0026amp; service_name, CallbackT \u0026amp;\u0026amp; callback, const rclcpp::QoS \u0026amp; qos = rclcpp::ServicesQoS(), rclcpp::CallbackGroup::SharedPtr group = nullptr); // 参数相关操作方法 // 其他服务方法 protected: Node( const Node \u0026amp; other, const std::string \u0026amp; sub_namespace); private: rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_base_; rclcpp::node_interfaces::NodeGraphInterface::SharedPtr node_graph_; rclcpp::node_interfaces::NodeLoggingInterface::SharedPtr node_logging_; rclcpp::node_interfaces::NodeTimersInterface::SharedPtr node_timers_; rclcpp::node_interfaces::NodeTopicsInterface::SharedPtr node_topics_; rclcpp::node_interfaces::NodeServicesInterface::SharedPtr node_services_; rclcpp::node_interfaces::NodeClockInterface::SharedPtr node_clock_; rclcpp::node_interfaces::NodeParametersInterface::SharedPtr node_parameters_; rclcpp::node_interfaces::NodeTimeSourceInterface::SharedPtr node_time_source_; rclcpp::node_interfaces::NodeTypeDescriptionsInterface::SharedPtr node_type_descriptions_; rclcpp::node_interfaces::NodeWaitablesInterface::SharedPtr node_waitables_; const rclcpp::NodeOptions node_options_; const std::string sub_namespace_; const std::string effective_namespace_; class NodeImpl; // This member is meant to be a place to backport features into stable distributions, // and new features targeting Rolling should not use this. // See the comment in node.cpp for more information. std::shared_ptr\u0026lt;NodeImpl\u0026gt; hidden_impl_{nullptr}; }; 2、启动 上面的代码示例中，main函数调用了三个ROS2 C++客户端库的函数：\n","keywords":["ROS2"],"articleBody":"ROS2是机器人领域的著名SDK，可以加速学习效率。ROS2主要解决了两个问题：\n通信：基于Node，包含topic、service、action通信方式 代码架构：模块化开发，简化维护 一、架构 userland: code\nclient: rclc rclcpp rclpy etc…\nabstract: rcl\nmiddleware: rmw rmw_implementation rmw_fastrtps etc …\ndds: fastdds Context_RTI etc…\n二、实现 ROS2代码惯例：\n./ ../ include/... # 头文件 src/... # 实现 1、Node实现 推荐继承Node实现业务功能, 主要选择合理的通信方式，注册回调函数。\nnamespace palomino { class VincentDriver : public rclcpp::Node { // ... }; } int main(int argc, char * argv[]) { rclcpp::init(argc, argv); rclcpp::spin(std::make_shared\u003cpalomino::VincentDriver\u003e()); rclcpp::shutdown(); return 0; } Node的声明：\n// node.hpp class Node : public std::enable_shared_from_this\u003cNode\u003e { public: explicit Node( const std::string \u0026 node_name, const NodeOptions \u0026 options = NodeOptions()); explicit Node( const std::string \u0026 node_name, const std::string \u0026 namespace_, const NodeOptions \u0026 options = NodeOptions()); virtual ~Node(); // 创建发布者 template\u003c typename MessageT, typename AllocatorT = std::allocator\u003cvoid\u003e, typename PublisherT = rclcpp::Publisher\u003cMessageT, AllocatorT\u003e\u003e std::shared_ptr\u003cPublisherT\u003e create_publisher( const std::string \u0026 topic_name, const rclcpp::QoS \u0026 qos, const PublisherOptionsWithAllocator\u003cAllocatorT\u003e \u0026 options = PublisherOptionsWithAllocator\u003cAllocatorT\u003e() ); // 创建订阅者 template\u003c typename MessageT, typename CallbackT, typename AllocatorT = std::allocator\u003cvoid\u003e, typename SubscriptionT = rclcpp::Subscription\u003cMessageT, AllocatorT\u003e, typename MessageMemoryStrategyT = typename SubscriptionT::MessageMemoryStrategyType \u003e std::shared_ptr\u003cSubscriptionT\u003e create_subscription( const std::string \u0026 topic_name, const rclcpp::QoS \u0026 qos, CallbackT \u0026\u0026 callback, const SubscriptionOptionsWithAllocator\u003cAllocatorT\u003e \u0026 options = SubscriptionOptionsWithAllocator\u003cAllocatorT\u003e(), typename MessageMemoryStrategyT::SharedPtr msg_mem_strat = ( MessageMemoryStrategyT::create_default() ) ); // 创建service的客户端 template\u003ctypename ServiceT\u003e typename rclcpp::Client\u003cServiceT\u003e::SharedPtr create_client( const std::string \u0026 service_name, const rclcpp::QoS \u0026 qos = rclcpp::ServicesQoS(), rclcpp::CallbackGroup::SharedPtr group = nullptr); // 创建service的服务端 template\u003ctypename ServiceT, typename CallbackT\u003e typename rclcpp::Service\u003cServiceT\u003e::SharedPtr create_service( const std::string \u0026 service_name, CallbackT \u0026\u0026 callback, const rclcpp::QoS \u0026 qos = rclcpp::ServicesQoS(), rclcpp::CallbackGroup::SharedPtr group = nullptr); // 参数相关操作方法 // 其他服务方法 protected: Node( const Node \u0026 other, const std::string \u0026 sub_namespace); private: rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_base_; rclcpp::node_interfaces::NodeGraphInterface::SharedPtr node_graph_; rclcpp::node_interfaces::NodeLoggingInterface::SharedPtr node_logging_; rclcpp::node_interfaces::NodeTimersInterface::SharedPtr node_timers_; rclcpp::node_interfaces::NodeTopicsInterface::SharedPtr node_topics_; rclcpp::node_interfaces::NodeServicesInterface::SharedPtr node_services_; rclcpp::node_interfaces::NodeClockInterface::SharedPtr node_clock_; rclcpp::node_interfaces::NodeParametersInterface::SharedPtr node_parameters_; rclcpp::node_interfaces::NodeTimeSourceInterface::SharedPtr node_time_source_; rclcpp::node_interfaces::NodeTypeDescriptionsInterface::SharedPtr node_type_descriptions_; rclcpp::node_interfaces::NodeWaitablesInterface::SharedPtr node_waitables_; const rclcpp::NodeOptions node_options_; const std::string sub_namespace_; const std::string effective_namespace_; class NodeImpl; // This member is meant to be a place to backport features into stable distributions, // and new features targeting Rolling should not use this. // See the comment in node.cpp for more information. std::shared_ptr\u003cNodeImpl\u003e hidden_impl_{nullptr}; }; 2、启动 上面的代码示例中，main函数调用了三个ROS2 C++客户端库的函数：\ninit: 初始化通信，设置全局信号处理 spin: 自旋监听、处理事件 shutdown: 关闭 1、init // utilities.cpp void init( int argc, char const * const * argv, const InitOptions \u0026 init_options, SignalHandlerOptions signal_handler_options) { using rclcpp::contexts::get_global_default_context; get_global_default_context()-\u003einit(argc, argv, init_options); // Install the signal handlers. install_signal_handlers(signal_handler_options); } 调用上下文init方法，进行具体的初始化：\n// context.cpp void Context::init( int argc, char const * const * argv, const rclcpp::InitOptions \u0026 init_options) { // 加锁 std::lock_guard\u003cstd::recursive_mutex\u003e init_lock(init_mutex_); if (this-\u003eis_valid()) { throw rclcpp::ContextAlreadyInitialized(); } this-\u003eclean_up(); rcl_context_t * context = new rcl_context_t; if (!context) { throw std::runtime_error(\"failed to allocate memory for rcl context\"); } *context = rcl_get_zero_initialized_context(); // 调用rcl_init rcl_ret_t ret = rcl_init(argc, argv, init_options.get_rcl_init_options(), context); if (RCL_RET_OK != ret) { delete context; rclcpp::exceptions::throw_from_rcl_error(ret, \"failed to initialize rcl\"); } rcl_context_.reset(context, __delete_context); ... // 设置日志器 // 检测未解析参数 // 内部数据维护 } Context init又调用了rcl库的init函数：\n// rcl/src/rcl/init.c rcl_ret_t rcl_init( int argc, char const * const * argv, const rcl_init_options_t * options, rcl_context_t * context) { rcl_ret_t fail_ret = RCL_RET_ERROR; // 参数解析 // 检测上下文实现 // 初始化rcl上下文 // 获取domain_id size_t * domain_id = \u0026context-\u003eimpl-\u003einit_options.impl-\u003ermw_init_options.domain_id; if (RCL_DEFAULT_DOMAIN_ID == *domain_id) { // Get actual domain id based on environment variable. ret = rcl_get_default_domain_id(domain_id); } // 发现配置 const rmw_discovery_options_t original_discovery_options = options-\u003eimpl-\u003ermw_init_options.discovery_options; rmw_discovery_options_t * discovery_options = \u0026context-\u003eimpl-\u003einit_options.impl-\u003ermw_init_options.discovery_options; // 很长的一串代码，发现配置 rmw_security_options_t * security_options = \u0026context-\u003eimpl-\u003einit_options.impl-\u003ermw_init_options.security_options; ret = rcl_get_security_options_from_environment( context-\u003eimpl-\u003einit_options.impl-\u003ermw_init_options.enclave, \u0026context-\u003eimpl-\u003eallocator, security_options); // Initialize rmw_init. rmw_ret_t rmw_ret = rmw_init( \u0026(context-\u003eimpl-\u003einit_options.impl-\u003ermw_init_options), \u0026(context-\u003eimpl-\u003ermw_context)); TRACETOOLS_TRACEPOINT(rcl_init, (const void *)context); return RCL_RET_OK; fail: __cleanup_context(context); return fail_ret; } rcl init函数又调用了rmw的初始化函数：\n// rmw_implementation/src/functions.cpp rmw_ret_t rmw_init(const rmw_init_options_t * options, rmw_context_t * context) { prefetch_symbols(); if (!symbol_rmw_init) { symbol_rmw_init = get_symbol(\"rmw_init\"); } if (!symbol_rmw_init) { return RMW_RET_ERROR; } typedef rmw_ret_t (* FunctionSignature)(const rmw_init_options_t *, rmw_context_t *); FunctionSignature func = reinterpret_cast\u003cFunctionSignature\u003e(symbol_rmw_init); return func(options, context); } rmw是DDS中间件实现的抽象层，根据环境变量加载DDS实现，fastdds的中间件实现如下：\n// rmw_fasttps/rmw_fastrtps_cpp/src/rmw_init.cpp rmw_ret_t rmw_init(const rmw_init_options_t * options, rmw_context_t * context) { // 参数检查 // domain_id auto restore_context = rcpputils::make_scope_exit( [context]() {*context = rmw_get_zero_initialized_context();}); context-\u003einstance_id = options-\u003einstance_id; context-\u003eimplementation_identifier = eprosima_fastrtps_identifier; context-\u003eactual_domain_id = RMW_DEFAULT_DOMAIN_ID == options-\u003edomain_id ? 0uL : options-\u003edomain_id; // 设置上下文实现 context-\u003eimpl = new (std::nothrow) rmw_context_impl_t(); auto cleanup_impl = rcpputils::make_scope_exit( [context]() {delete context-\u003eimpl;}); context-\u003eimpl-\u003eis_shutdown = false; context-\u003eoptions = rmw_get_zero_initialized_init_options(); rmw_ret_t ret = rmw_init_options_copy(options, \u0026context-\u003eoptions); cleanup_impl.cancel(); restore_context.cancel(); return RMW_RET_OK; } 2、spin spin有两个重载的函数实现：\n// rclcpp/src/rclcpp/executors.cpp // 重载入口函数 void rclcpp::spin(rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr) { rclcpp::ExecutorOptions options; options.context = node_ptr-\u003eget_context(); // 执行器 rclcpp::executors::SingleThreadedExecutor exec(options); // 添加节点 exec.add_node(node_ptr); // 自旋，执行逻辑 exec.spin(); // 去除节点 exec.remove_node(node_ptr); } // 入口函数 void rclcpp::spin(rclcpp::Node::SharedPtr node_ptr) { rclcpp::spin(node_ptr-\u003eget_node_base_interface()); } SingleThreadedExecutor spin方法的实现：\n// rclcpp/src/rclcpp/executors/single_threaded_executor.cpp void SingleThreadedExecutor::spin() { if (spinning.exchange(true)) { throw std::runtime_error(\"spin() called while already spinning\"); } RCPPUTILS_SCOPE_EXIT(wait_result_.reset();this-\u003espinning.store(false);); // Clear any previous result and rebuild the waitset this-\u003ewait_result_.reset(); this-\u003eentities_need_rebuild_ = true; // 单循环中获取可执行的任务并执行 while (rclcpp::ok(this-\u003econtext_) \u0026\u0026 spinning.load()) { rclcpp::AnyExecutable any_executable; // 获取成功返回 // 否则超时重试一次 /* 内部调用 bool Executor::get_next_ready_executable(AnyExecutable \u0026 any_executable); 该函数依次从timer、subscription、services、clients、waitables、callback_group获取可执行任务 */ if (get_next_executable(any_executable)) { // 根据上一步获取的任务类型，通过dispatch分发给回调函数执行 execute_any_executable(any_executable); } } } 3、shutdown init的逆操作：\n// rclcpp/src/rclcpp/utilities.cpp bool shutdown(Context::SharedPtr context, const std::string \u0026 reason) { using rclcpp::contexts::get_global_default_context; auto default_context = get_global_default_context(); if (nullptr == context) { context = default_context; } bool ret = context-\u003eshutdown(reason); if (context == default_context) { uninstall_signal_handlers(); } return ret; } 3、信号处理 在init和shutdown的过程中都有信号处理的设置：\n// init install_signal_handlers(signal_handler_options); // shutdown uninstall_signal_handlers(); ROS2使用一个单独的线程处理上下文的shutdown，保证安全退出：\nbool SignalHandler::install(SignalHandlerOptions signal_handler_options) { // 只保留了核心函数 // 加锁，保证线程安全 // 原子操作 ... setup_wait_for_signal(); signal_received_.store(false); SignalHandler::signal_handler_type handler_argument; handler_argument = \u0026this-\u003esignal_handler; // 注册信号处理函数 old_sigint_handler_ = set_signal_handler(SIGINT, handler_argument); old_sigterm_handler_ = set_signal_handler(SIGTERM, handler_argument); // 新线程，检测signal_received_是否被设置 // 被设置后获取所有contexts，调用shutdown signal_handler_thread_ = std::thread(\u0026SignalHandler::deferred_signal_handler, this); return true; } 内部实现使用sigaction或signal信号处理机制，sigaction是 POSIX 标准推荐的信号处理方式，支持更精细的控制（如阻塞其他信号、获取信号上下文信息等）。\n","wordCount":"842","inLanguage":"en","image":"https://solaim.github.io/img/favicon.webp","datePublished":"2025-05-07T10:20:33+08:00","dateModified":"2025-05-07T10:20:33+08:00","author":{"@type":"Person","name":"Jerry Wang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://solaim.github.io/posts/ros2%E6%9E%B6%E6%9E%84%E5%92%8C%E5%AE%9E%E7%8E%B0/"},"publisher":{"@type":"Organization","name":"Jerry Wang","logo":{"@type":"ImageObject","url":"https://solaim.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://solaim.github.io/ accesskey=h title="首页 (Alt + H)"><img src=https://solaim.github.io/apple-touch-icon.png alt aria-label=logo height=35>首页</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://solaim.github.io/categories/ title=🕸分类><span>🕸分类</span></a></li><li><a href=https://solaim.github.io/tags/ title=🐚标签><span>🐚标签</span></a></li><li><a href=https://solaim.github.io/about/ title=🌏关于><span>🌏关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://solaim.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://solaim.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">ROS2架构和实现</h1><div class=post-meta><span title='2025-05-07 10:20:33 +0800 +0800'>2025-05-07</span>&nbsp;·&nbsp;Jerry Wang</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#一架构>一、架构</a></li><li><a href=#二实现>二、实现</a><ul><li><a href=#1node实现>1、Node实现</a></li><li><a href=#2启动>2、启动</a></li><li><a href=#3信号处理>3、信号处理</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>ROS2是机器人领域的著名SDK，可以加速学习效率。ROS2主要解决了两个问题：</p><ul><li>通信：基于Node，包含topic、service、action通信方式</li><li>代码架构：模块化开发，简化维护</li></ul><h2 id=一架构>一、架构<a hidden class=anchor aria-hidden=true href=#一架构>#</a></h2><p>userland: code</p><p>client: rclc rclcpp rclpy etc&mldr;</p><p>abstract: rcl</p><p>middleware: rmw rmw_implementation rmw_fastrtps etc &mldr;</p><p>dds: fastdds Context_RTI etc&mldr;</p><h2 id=二实现>二、实现<a hidden class=anchor aria-hidden=true href=#二实现>#</a></h2><p>ROS2代码惯例：</p><pre tabindex=0><code>./
../
include/... # 头文件
src/...     # 实现
</code></pre><h3 id=1node实现>1、Node实现<a hidden class=anchor aria-hidden=true href=#1node实现>#</a></h3><p>推荐继承Node实现业务功能, 主要选择合理的通信方式，注册回调函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>palomino</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>VincentDriver</span> <span class=o>:</span> <span class=k>public</span> <span class=n>rclcpp</span><span class=o>::</span><span class=n>Node</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>rclcpp</span><span class=o>::</span><span class=n>init</span><span class=p>(</span><span class=n>argc</span><span class=p>,</span> <span class=n>argv</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>rclcpp</span><span class=o>::</span><span class=n>spin</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>palomino</span><span class=o>::</span><span class=n>VincentDriver</span><span class=o>&gt;</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=n>rclcpp</span><span class=o>::</span><span class=n>shutdown</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Node的声明：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// node.hpp
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Node</span> <span class=o>:</span> <span class=k>public</span> <span class=n>std</span><span class=o>::</span><span class=n>enable_shared_from_this</span><span class=o>&lt;</span><span class=n>Node</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>explicit</span> <span class=n>Node</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span> <span class=n>node_name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>NodeOptions</span> <span class=o>&amp;</span> <span class=n>options</span> <span class=o>=</span> <span class=n>NodeOptions</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>explicit</span> <span class=nf>Node</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span> <span class=n>node_name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span> <span class=n>namespace_</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>NodeOptions</span> <span class=o>&amp;</span> <span class=n>options</span> <span class=o>=</span> <span class=n>NodeOptions</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>virtual</span> <span class=o>~</span><span class=n>Node</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 创建发布者
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>template</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>MessageT</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>AllocatorT</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>allocator</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>PublisherT</span> <span class=o>=</span> <span class=n>rclcpp</span><span class=o>::</span><span class=n>Publisher</span><span class=o>&lt;</span><span class=n>MessageT</span><span class=p>,</span> <span class=n>AllocatorT</span><span class=o>&gt;&gt;</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>PublisherT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=n>create_publisher</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span> <span class=n>topic_name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>rclcpp</span><span class=o>::</span><span class=n>QoS</span> <span class=o>&amp;</span> <span class=n>qos</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>PublisherOptionsWithAllocator</span><span class=o>&lt;</span><span class=n>AllocatorT</span><span class=o>&gt;</span> <span class=o>&amp;</span> <span class=n>options</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=n>PublisherOptionsWithAllocator</span><span class=o>&lt;</span><span class=n>AllocatorT</span><span class=o>&gt;</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=c1>// 创建订阅者
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>template</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>MessageT</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>CallbackT</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>AllocatorT</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>allocator</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>SubscriptionT</span> <span class=o>=</span> <span class=n>rclcpp</span><span class=o>::</span><span class=n>Subscription</span><span class=o>&lt;</span><span class=n>MessageT</span><span class=p>,</span> <span class=n>AllocatorT</span><span class=o>&gt;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>MessageMemoryStrategyT</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>SubscriptionT</span><span class=o>::</span><span class=n>MessageMemoryStrategyType</span>
</span></span><span class=line><span class=cl>  <span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>SubscriptionT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=n>create_subscription</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span> <span class=n>topic_name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>rclcpp</span><span class=o>::</span><span class=n>QoS</span> <span class=o>&amp;</span> <span class=n>qos</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>CallbackT</span> <span class=o>&amp;&amp;</span> <span class=n>callback</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>SubscriptionOptionsWithAllocator</span><span class=o>&lt;</span><span class=n>AllocatorT</span><span class=o>&gt;</span> <span class=o>&amp;</span> <span class=n>options</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=n>SubscriptionOptionsWithAllocator</span><span class=o>&lt;</span><span class=n>AllocatorT</span><span class=o>&gt;</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>MessageMemoryStrategyT</span><span class=o>::</span><span class=n>SharedPtr</span> <span class=n>msg_mem_strat</span> <span class=o>=</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=n>MessageMemoryStrategyT</span><span class=o>::</span><span class=n>create_default</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 创建service的客户端
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>ServiceT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=k>typename</span> <span class=n>rclcpp</span><span class=o>::</span><span class=n>Client</span><span class=o>&lt;</span><span class=n>ServiceT</span><span class=o>&gt;::</span><span class=n>SharedPtr</span>
</span></span><span class=line><span class=cl>  <span class=n>create_client</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span> <span class=n>service_name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>rclcpp</span><span class=o>::</span><span class=n>QoS</span> <span class=o>&amp;</span> <span class=n>qos</span> <span class=o>=</span> <span class=n>rclcpp</span><span class=o>::</span><span class=n>ServicesQoS</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>    <span class=n>rclcpp</span><span class=o>::</span><span class=n>CallbackGroup</span><span class=o>::</span><span class=n>SharedPtr</span> <span class=n>group</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 创建service的服务端
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>ServiceT</span><span class=p>,</span> <span class=k>typename</span> <span class=n>CallbackT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=k>typename</span> <span class=n>rclcpp</span><span class=o>::</span><span class=n>Service</span><span class=o>&lt;</span><span class=n>ServiceT</span><span class=o>&gt;::</span><span class=n>SharedPtr</span>
</span></span><span class=line><span class=cl>  <span class=n>create_service</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span> <span class=n>service_name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>CallbackT</span> <span class=o>&amp;&amp;</span> <span class=n>callback</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>rclcpp</span><span class=o>::</span><span class=n>QoS</span> <span class=o>&amp;</span> <span class=n>qos</span> <span class=o>=</span> <span class=n>rclcpp</span><span class=o>::</span><span class=n>ServicesQoS</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>    <span class=n>rclcpp</span><span class=o>::</span><span class=n>CallbackGroup</span><span class=o>::</span><span class=n>SharedPtr</span> <span class=n>group</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 参数相关操作方法
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 其他服务方法
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>Node</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Node</span> <span class=o>&amp;</span> <span class=n>other</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span> <span class=n>sub_namespace</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>rclcpp</span><span class=o>::</span><span class=n>node_interfaces</span><span class=o>::</span><span class=n>NodeBaseInterface</span><span class=o>::</span><span class=n>SharedPtr</span> <span class=n>node_base_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>rclcpp</span><span class=o>::</span><span class=n>node_interfaces</span><span class=o>::</span><span class=n>NodeGraphInterface</span><span class=o>::</span><span class=n>SharedPtr</span> <span class=n>node_graph_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>rclcpp</span><span class=o>::</span><span class=n>node_interfaces</span><span class=o>::</span><span class=n>NodeLoggingInterface</span><span class=o>::</span><span class=n>SharedPtr</span> <span class=n>node_logging_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>rclcpp</span><span class=o>::</span><span class=n>node_interfaces</span><span class=o>::</span><span class=n>NodeTimersInterface</span><span class=o>::</span><span class=n>SharedPtr</span> <span class=n>node_timers_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>rclcpp</span><span class=o>::</span><span class=n>node_interfaces</span><span class=o>::</span><span class=n>NodeTopicsInterface</span><span class=o>::</span><span class=n>SharedPtr</span> <span class=n>node_topics_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>rclcpp</span><span class=o>::</span><span class=n>node_interfaces</span><span class=o>::</span><span class=n>NodeServicesInterface</span><span class=o>::</span><span class=n>SharedPtr</span> <span class=n>node_services_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>rclcpp</span><span class=o>::</span><span class=n>node_interfaces</span><span class=o>::</span><span class=n>NodeClockInterface</span><span class=o>::</span><span class=n>SharedPtr</span> <span class=n>node_clock_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>rclcpp</span><span class=o>::</span><span class=n>node_interfaces</span><span class=o>::</span><span class=n>NodeParametersInterface</span><span class=o>::</span><span class=n>SharedPtr</span> <span class=n>node_parameters_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>rclcpp</span><span class=o>::</span><span class=n>node_interfaces</span><span class=o>::</span><span class=n>NodeTimeSourceInterface</span><span class=o>::</span><span class=n>SharedPtr</span> <span class=n>node_time_source_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>rclcpp</span><span class=o>::</span><span class=n>node_interfaces</span><span class=o>::</span><span class=n>NodeTypeDescriptionsInterface</span><span class=o>::</span><span class=n>SharedPtr</span> <span class=n>node_type_descriptions_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>rclcpp</span><span class=o>::</span><span class=n>node_interfaces</span><span class=o>::</span><span class=n>NodeWaitablesInterface</span><span class=o>::</span><span class=n>SharedPtr</span> <span class=n>node_waitables_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>rclcpp</span><span class=o>::</span><span class=n>NodeOptions</span> <span class=n>node_options_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>sub_namespace_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>effective_namespace_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>class</span> <span class=nc>NodeImpl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// This member is meant to be a place to backport features into stable distributions,
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// and new features targeting Rolling should not use this.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// See the comment in node.cpp for more information.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>NodeImpl</span><span class=o>&gt;</span> <span class=n>hidden_impl_</span><span class=p>{</span><span class=k>nullptr</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=2启动>2、启动<a hidden class=anchor aria-hidden=true href=#2启动>#</a></h3><p>上面的代码示例中，main函数调用了三个ROS2 C++客户端库的函数：</p><ul><li>init: 初始化通信，设置全局信号处理</li><li>spin: 自旋监听、处理事件</li><li>shutdown: 关闭</li></ul><h4 id=1init>1、init<a hidden class=anchor aria-hidden=true href=#1init>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// utilities.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>init</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>argc</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=k>const</span> <span class=o>*</span> <span class=k>const</span> <span class=o>*</span> <span class=n>argv</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>InitOptions</span> <span class=o>&amp;</span> <span class=n>init_options</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>SignalHandlerOptions</span> <span class=n>signal_handler_options</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>using</span> <span class=n>rclcpp</span><span class=o>::</span><span class=n>contexts</span><span class=o>::</span><span class=n>get_global_default_context</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>get_global_default_context</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>init</span><span class=p>(</span><span class=n>argc</span><span class=p>,</span> <span class=n>argv</span><span class=p>,</span> <span class=n>init_options</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Install the signal handlers.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>install_signal_handlers</span><span class=p>(</span><span class=n>signal_handler_options</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>调用上下文init方法，进行具体的初始化：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// context.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=n>Context</span><span class=o>::</span><span class=n>init</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>argc</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=k>const</span> <span class=o>*</span> <span class=k>const</span> <span class=o>*</span> <span class=n>argv</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>rclcpp</span><span class=o>::</span><span class=n>InitOptions</span> <span class=o>&amp;</span> <span class=n>init_options</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 加锁
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>lock_guard</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>recursive_mutex</span><span class=o>&gt;</span> <span class=n>init_lock</span><span class=p>(</span><span class=n>init_mutex_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=k>this</span><span class=o>-&gt;</span><span class=n>is_valid</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=n>rclcpp</span><span class=o>::</span><span class=n>ContextAlreadyInitialized</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>this</span><span class=o>-&gt;</span><span class=n>clean_up</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>rcl_context_t</span> <span class=o>*</span> <span class=n>context</span> <span class=o>=</span> <span class=k>new</span> <span class=n>rcl_context_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>runtime_error</span><span class=p>(</span><span class=s>&#34;failed to allocate memory for rcl context&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=n>context</span> <span class=o>=</span> <span class=n>rcl_get_zero_initialized_context</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 调用rcl_init
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>rcl_ret_t</span> <span class=n>ret</span> <span class=o>=</span> <span class=n>rcl_init</span><span class=p>(</span><span class=n>argc</span><span class=p>,</span> <span class=n>argv</span><span class=p>,</span> <span class=n>init_options</span><span class=p>.</span><span class=n>get_rcl_init_options</span><span class=p>(),</span> <span class=n>context</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>RCL_RET_OK</span> <span class=o>!=</span> <span class=n>ret</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>context</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>rclcpp</span><span class=o>::</span><span class=n>exceptions</span><span class=o>::</span><span class=n>throw_from_rcl_error</span><span class=p>(</span><span class=n>ret</span><span class=p>,</span> <span class=s>&#34;failed to initialize rcl&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>rcl_context_</span><span class=p>.</span><span class=n>reset</span><span class=p>(</span><span class=n>context</span><span class=p>,</span> <span class=n>__delete_context</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 设置日志器
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 检测未解析参数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 内部数据维护
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>Context init又调用了rcl库的init函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// rcl/src/rcl/init.c 
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>rcl_ret_t</span>
</span></span><span class=line><span class=cl><span class=nf>rcl_init</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>argc</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=k>const</span> <span class=o>*</span> <span class=k>const</span> <span class=o>*</span> <span class=n>argv</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>rcl_init_options_t</span> <span class=o>*</span> <span class=n>options</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=kt>rcl_context_t</span> <span class=o>*</span> <span class=n>context</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>rcl_ret_t</span> <span class=n>fail_ret</span> <span class=o>=</span> <span class=n>RCL_RET_ERROR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 参数解析
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 检测上下文实现
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 初始化rcl上下文
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 获取domain_id
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>size_t</span> <span class=o>*</span> <span class=n>domain_id</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>context</span><span class=o>-&gt;</span><span class=n>impl</span><span class=o>-&gt;</span><span class=n>init_options</span><span class=p>.</span><span class=n>impl</span><span class=o>-&gt;</span><span class=n>rmw_init_options</span><span class=p>.</span><span class=n>domain_id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>RCL_DEFAULT_DOMAIN_ID</span> <span class=o>==</span> <span class=o>*</span><span class=n>domain_id</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Get actual domain id based on environment variable.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ret</span> <span class=o>=</span> <span class=nf>rcl_get_default_domain_id</span><span class=p>(</span><span class=n>domain_id</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=c1>// 发现配置
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=kt>rmw_discovery_options_t</span> <span class=n>original_discovery_options</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=n>options</span><span class=o>-&gt;</span><span class=n>impl</span><span class=o>-&gt;</span><span class=n>rmw_init_options</span><span class=p>.</span><span class=n>discovery_options</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>rmw_discovery_options_t</span> <span class=o>*</span> <span class=n>discovery_options</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=o>&amp;</span><span class=n>context</span><span class=o>-&gt;</span><span class=n>impl</span><span class=o>-&gt;</span><span class=n>init_options</span><span class=p>.</span><span class=n>impl</span><span class=o>-&gt;</span><span class=n>rmw_init_options</span><span class=p>.</span><span class=n>discovery_options</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 很长的一串代码，发现配置
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=kt>rmw_security_options_t</span> <span class=o>*</span> <span class=n>security_options</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=o>&amp;</span><span class=n>context</span><span class=o>-&gt;</span><span class=n>impl</span><span class=o>-&gt;</span><span class=n>init_options</span><span class=p>.</span><span class=n>impl</span><span class=o>-&gt;</span><span class=n>rmw_init_options</span><span class=p>.</span><span class=n>security_options</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>ret</span> <span class=o>=</span> <span class=nf>rcl_get_security_options_from_environment</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>context</span><span class=o>-&gt;</span><span class=n>impl</span><span class=o>-&gt;</span><span class=n>init_options</span><span class=p>.</span><span class=n>impl</span><span class=o>-&gt;</span><span class=n>rmw_init_options</span><span class=p>.</span><span class=n>enclave</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=o>&amp;</span><span class=n>context</span><span class=o>-&gt;</span><span class=n>impl</span><span class=o>-&gt;</span><span class=n>allocator</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>security_options</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Initialize rmw_init.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>rmw_ret_t</span> <span class=n>rmw_ret</span> <span class=o>=</span> <span class=nf>rmw_init</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&amp;</span><span class=p>(</span><span class=n>context</span><span class=o>-&gt;</span><span class=n>impl</span><span class=o>-&gt;</span><span class=n>init_options</span><span class=p>.</span><span class=n>impl</span><span class=o>-&gt;</span><span class=n>rmw_init_options</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=o>&amp;</span><span class=p>(</span><span class=n>context</span><span class=o>-&gt;</span><span class=n>impl</span><span class=o>-&gt;</span><span class=n>rmw_context</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>TRACETOOLS_TRACEPOINT</span><span class=p>(</span><span class=n>rcl_init</span><span class=p>,</span> <span class=p>(</span><span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>context</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>RCL_RET_OK</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>fail</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=nf>__cleanup_context</span><span class=p>(</span><span class=n>context</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>fail_ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>rcl init函数又调用了rmw的初始化函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// rmw_implementation/src/functions.cpp 
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>rmw_ret_t</span>
</span></span><span class=line><span class=cl><span class=nf>rmw_init</span><span class=p>(</span><span class=k>const</span> <span class=kt>rmw_init_options_t</span> <span class=o>*</span> <span class=n>options</span><span class=p>,</span> <span class=kt>rmw_context_t</span> <span class=o>*</span> <span class=n>context</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>prefetch_symbols</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>symbol_rmw_init</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>symbol_rmw_init</span> <span class=o>=</span> <span class=nf>get_symbol</span><span class=p>(</span><span class=s>&#34;rmw_init&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>symbol_rmw_init</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>RMW_RET_ERROR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>typedef</span> <span class=kt>rmw_ret_t</span> <span class=p>(</span><span class=o>*</span> <span class=n>FunctionSignature</span><span class=p>)(</span><span class=k>const</span> <span class=kt>rmw_init_options_t</span> <span class=o>*</span><span class=p>,</span> <span class=kt>rmw_context_t</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>FunctionSignature</span> <span class=n>func</span> <span class=o>=</span> <span class=n>reinterpret_cast</span><span class=o>&lt;</span><span class=n>FunctionSignature</span><span class=o>&gt;</span><span class=p>(</span><span class=n>symbol_rmw_init</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>func</span><span class=p>(</span><span class=n>options</span><span class=p>,</span> <span class=n>context</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>rmw是DDS中间件实现的抽象层，根据环境变量加载DDS实现，fastdds的中间件实现如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// rmw_fasttps/rmw_fastrtps_cpp/src/rmw_init.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>rmw_ret_t</span>
</span></span><span class=line><span class=cl><span class=nf>rmw_init</span><span class=p>(</span><span class=k>const</span> <span class=n>rmw_init_options_t</span> <span class=o>*</span> <span class=n>options</span><span class=p>,</span> <span class=n>rmw_context_t</span> <span class=o>*</span> <span class=n>context</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 参数检查
</span></span></span><span class=line><span class=cl><span class=c1></span>  
</span></span><span class=line><span class=cl>  <span class=c1>// domain_id
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>auto</span> <span class=n>restore_context</span> <span class=o>=</span> <span class=n>rcpputils</span><span class=o>::</span><span class=n>make_scope_exit</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>context</span><span class=p>]()</span> <span class=p>{</span><span class=o>*</span><span class=n>context</span> <span class=o>=</span> <span class=n>rmw_get_zero_initialized_context</span><span class=p>();});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>context</span><span class=o>-&gt;</span><span class=n>instance_id</span> <span class=o>=</span> <span class=n>options</span><span class=o>-&gt;</span><span class=n>instance_id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>context</span><span class=o>-&gt;</span><span class=n>implementation_identifier</span> <span class=o>=</span> <span class=n>eprosima_fastrtps_identifier</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>context</span><span class=o>-&gt;</span><span class=n>actual_domain_id</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=n>RMW_DEFAULT_DOMAIN_ID</span> <span class=o>==</span> <span class=n>options</span><span class=o>-&gt;</span><span class=n>domain_id</span> <span class=o>?</span> <span class=mi>0uL</span> <span class=o>:</span> <span class=n>options</span><span class=o>-&gt;</span><span class=n>domain_id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 设置上下文实现
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>context</span><span class=o>-&gt;</span><span class=n>impl</span> <span class=o>=</span> <span class=k>new</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>nothrow</span><span class=p>)</span> <span class=n>rmw_context_impl_t</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=n>cleanup_impl</span> <span class=o>=</span> <span class=n>rcpputils</span><span class=o>::</span><span class=n>make_scope_exit</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>context</span><span class=p>]()</span> <span class=p>{</span><span class=k>delete</span> <span class=n>context</span><span class=o>-&gt;</span><span class=n>impl</span><span class=p>;});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>context</span><span class=o>-&gt;</span><span class=n>impl</span><span class=o>-&gt;</span><span class=n>is_shutdown</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>context</span><span class=o>-&gt;</span><span class=n>options</span> <span class=o>=</span> <span class=n>rmw_get_zero_initialized_init_options</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>rmw_ret_t</span> <span class=n>ret</span> <span class=o>=</span> <span class=n>rmw_init_options_copy</span><span class=p>(</span><span class=n>options</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>context</span><span class=o>-&gt;</span><span class=n>options</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>cleanup_impl</span><span class=p>.</span><span class=n>cancel</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>restore_context</span><span class=p>.</span><span class=n>cancel</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>RMW_RET_OK</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=2spin>2、spin<a hidden class=anchor aria-hidden=true href=#2spin>#</a></h4><p>spin有两个重载的函数实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// rclcpp/src/rclcpp/executors.cpp
</span></span></span><span class=line><span class=cl><span class=c1>// 重载入口函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=n>rclcpp</span><span class=o>::</span><span class=n>spin</span><span class=p>(</span><span class=n>rclcpp</span><span class=o>::</span><span class=n>node_interfaces</span><span class=o>::</span><span class=n>NodeBaseInterface</span><span class=o>::</span><span class=n>SharedPtr</span> <span class=n>node_ptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>rclcpp</span><span class=o>::</span><span class=n>ExecutorOptions</span> <span class=n>options</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>options</span><span class=p>.</span><span class=n>context</span> <span class=o>=</span> <span class=n>node_ptr</span><span class=o>-&gt;</span><span class=n>get_context</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 执行器
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>rclcpp</span><span class=o>::</span><span class=n>executors</span><span class=o>::</span><span class=n>SingleThreadedExecutor</span> <span class=n>exec</span><span class=p>(</span><span class=n>options</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 添加节点
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>exec</span><span class=p>.</span><span class=n>add_node</span><span class=p>(</span><span class=n>node_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 自旋，执行逻辑
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>exec</span><span class=p>.</span><span class=n>spin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 去除节点
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>exec</span><span class=p>.</span><span class=n>remove_node</span><span class=p>(</span><span class=n>node_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 入口函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=n>rclcpp</span><span class=o>::</span><span class=n>spin</span><span class=p>(</span><span class=n>rclcpp</span><span class=o>::</span><span class=n>Node</span><span class=o>::</span><span class=n>SharedPtr</span> <span class=n>node_ptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>rclcpp</span><span class=o>::</span><span class=n>spin</span><span class=p>(</span><span class=n>node_ptr</span><span class=o>-&gt;</span><span class=n>get_node_base_interface</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>SingleThreadedExecutor spin方法的实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// rclcpp/src/rclcpp/executors/single_threaded_executor.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=n>SingleThreadedExecutor</span><span class=o>::</span><span class=n>spin</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>spinning</span><span class=p>.</span><span class=n>exchange</span><span class=p>(</span><span class=nb>true</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>runtime_error</span><span class=p>(</span><span class=s>&#34;spin() called while already spinning&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>RCPPUTILS_SCOPE_EXIT</span><span class=p>(</span><span class=n>wait_result_</span><span class=p>.</span><span class=n>reset</span><span class=p>();</span><span class=k>this</span><span class=o>-&gt;</span><span class=n>spinning</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>false</span><span class=p>););</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Clear any previous result and rebuild the waitset
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>this</span><span class=o>-&gt;</span><span class=n>wait_result_</span><span class=p>.</span><span class=n>reset</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>this</span><span class=o>-&gt;</span><span class=n>entities_need_rebuild_</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 单循环中获取可执行的任务并执行
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>while</span> <span class=p>(</span><span class=n>rclcpp</span><span class=o>::</span><span class=n>ok</span><span class=p>(</span><span class=k>this</span><span class=o>-&gt;</span><span class=n>context_</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>spinning</span><span class=p>.</span><span class=n>load</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>rclcpp</span><span class=o>::</span><span class=n>AnyExecutable</span> <span class=n>any_executable</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 获取成功返回
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 否则超时重试一次
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>    内部调用
</span></span></span><span class=line><span class=cl><span class=cm>    bool
</span></span></span><span class=line><span class=cl><span class=cm>    Executor::get_next_ready_executable(AnyExecutable &amp; any_executable);
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>    该函数依次从timer、subscription、services、clients、waitables、callback_group获取可执行任务
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>get_next_executable</span><span class=p>(</span><span class=n>any_executable</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 根据上一步获取的任务类型，通过dispatch分发给回调函数执行
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>execute_any_executable</span><span class=p>(</span><span class=n>any_executable</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=3shutdown>3、shutdown<a hidden class=anchor aria-hidden=true href=#3shutdown>#</a></h4><p>init的逆操作：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// rclcpp/src/rclcpp/utilities.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=nf>shutdown</span><span class=p>(</span><span class=n>Context</span><span class=o>::</span><span class=n>SharedPtr</span> <span class=n>context</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span> <span class=n>reason</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>using</span> <span class=n>rclcpp</span><span class=o>::</span><span class=n>contexts</span><span class=o>::</span><span class=n>get_global_default_context</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=n>default_context</span> <span class=o>=</span> <span class=n>get_global_default_context</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=k>nullptr</span> <span class=o>==</span> <span class=n>context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>context</span> <span class=o>=</span> <span class=n>default_context</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>ret</span> <span class=o>=</span> <span class=n>context</span><span class=o>-&gt;</span><span class=n>shutdown</span><span class=p>(</span><span class=n>reason</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>context</span> <span class=o>==</span> <span class=n>default_context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>uninstall_signal_handlers</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=3信号处理>3、信号处理<a hidden class=anchor aria-hidden=true href=#3信号处理>#</a></h3><p>在init和shutdown的过程中都有信号处理的设置：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>  <span class=c1>// init
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>install_signal_handlers</span><span class=p>(</span><span class=n>signal_handler_options</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// shutdown
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uninstall_signal_handlers</span><span class=p>();</span>
</span></span></code></pre></div><p>ROS2使用一个单独的线程处理上下文的shutdown，保证安全退出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=n>SignalHandler</span><span class=o>::</span><span class=n>install</span><span class=p>(</span><span class=n>SignalHandlerOptions</span> <span class=n>signal_handler_options</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 只保留了核心函数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 加锁，保证线程安全
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 原子操作
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>setup_wait_for_signal</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>signal_received_</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>SignalHandler</span><span class=o>::</span><span class=n>signal_handler_type</span> <span class=n>handler_argument</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>handler_argument</span> <span class=o>=</span> <span class=o>&amp;</span><span class=k>this</span><span class=o>-&gt;</span><span class=n>signal_handler</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 注册信号处理函数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>old_sigint_handler_</span> <span class=o>=</span> <span class=n>set_signal_handler</span><span class=p>(</span><span class=n>SIGINT</span><span class=p>,</span> <span class=n>handler_argument</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>old_sigterm_handler_</span> <span class=o>=</span> <span class=n>set_signal_handler</span><span class=p>(</span><span class=n>SIGTERM</span><span class=p>,</span> <span class=n>handler_argument</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 新线程，检测signal_received_是否被设置
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 被设置后获取所有contexts，调用shutdown
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>signal_handler_thread_</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=kr>thread</span><span class=p>(</span><span class=o>&amp;</span><span class=n>SignalHandler</span><span class=o>::</span><span class=n>deferred_signal_handler</span><span class=p>,</span> <span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>内部实现使用sigaction或signal信号处理机制，sigaction是 POSIX 标准推荐的信号处理方式，支持更精细的控制（如阻塞其他信号、获取信号上下文信息等）。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://solaim.github.io/tags/ros2/>ROS2</a></li></ul><nav class=paginav><a class=prev href=https://solaim.github.io/posts/ai_agent%E7%BA%B5%E8%A7%88/><span class=title>« Prev</span><br><span>AI Agent纵览</span>
</a><a class=next href=https://solaim.github.io/posts/%E8%AF%B4%E8%AF%B4k8s%E7%BD%91%E7%BB%9C/><span class=title>Next »</span><br><span>说说k8s网络</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://solaim.github.io/>Jerry Wang</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>