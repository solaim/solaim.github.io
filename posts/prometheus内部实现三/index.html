<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Prometheus内部实现(三) | Jerry Wang</title>
<meta name=keywords content="Golang,Prometheus,Observability"><meta name=description content="
非线性 => 线性，混乱 => 秩序
上一篇博文主要写了Prometheus server的启动过程，但是并没有深入各个组件，了解其具体实现，这篇文件主要介绍Initial configuration loading部分。
Prometheus server的main函数有两个很精彩的实现，一个是reloader的注册，一个是组件启动。但是有个问题，所有的组件都是同时启动的吗？还是有什么顺序？
我们列一个组件清单：
- Termination handler.
- Scrape discovery manager.
- Notify discovery manager.
- Scrape manager.
- Reload handler.
- Rule manager.
- TSDB.
- Web handler.
- Notifier.
再来看一下组件启动使用的底层技术:

run.Group is a universal mechanism to manage goroutine lifecycles.
Create a zero-value run.Group, and then add actors to it. Actors are defined as a pair of functions: an execute function, which should run synchronously; and an interrupt function, which, when invoked, should cause the execute function to return. Finally, invoke Run, which concurrently runs all of the actors, waits until the first actor exits, invokes the interrupt functions, and finally returns control to the caller only once all actors have returned. This general-purpose API allows callers to model pretty much any runnable task, and achieve well-defined lifecycle semantics for the group."><meta name=author content="Jerry Wang"><link rel=canonical href=https://solaim.github.io/posts/prometheus%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E4%B8%89/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://solaim.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://solaim.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://solaim.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://solaim.github.io/apple-touch-icon.png><link rel=mask-icon href=https://solaim.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://solaim.github.io/posts/prometheus%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E4%B8%89/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://solaim.github.io/posts/prometheus%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E4%B8%89/"><meta property="og:site_name" content="Jerry Wang"><meta property="og:title" content="Prometheus内部实现(三)"><meta property="og:description" content=" 非线性 => 线性，混乱 => 秩序
上一篇博文主要写了Prometheus server的启动过程，但是并没有深入各个组件，了解其具体实现，这篇文件主要介绍Initial configuration loading部分。
Prometheus server的main函数有两个很精彩的实现，一个是reloader的注册，一个是组件启动。但是有个问题，所有的组件都是同时启动的吗？还是有什么顺序？
我们列一个组件清单：
- Termination handler. - Scrape discovery manager. - Notify discovery manager. - Scrape manager. - Reload handler. - Rule manager. - TSDB. - Web handler. - Notifier. 再来看一下组件启动使用的底层技术:
run.Group is a universal mechanism to manage goroutine lifecycles.
Create a zero-value run.Group, and then add actors to it. Actors are defined as a pair of functions: an execute function, which should run synchronously; and an interrupt function, which, when invoked, should cause the execute function to return. Finally, invoke Run, which concurrently runs all of the actors, waits until the first actor exits, invokes the interrupt functions, and finally returns control to the caller only once all actors have returned. This general-purpose API allows callers to model pretty much any runnable task, and achieve well-defined lifecycle semantics for the group."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-20T21:29:33+08:00"><meta property="article:modified_time" content="2021-03-20T21:29:33+08:00"><meta property="article:tag" content="Golang"><meta property="article:tag" content="Prometheus"><meta property="article:tag" content="Observability"><meta property="og:image" content="https://solaim.github.io/img/favicon.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://solaim.github.io/img/favicon.webp"><meta name=twitter:title content="Prometheus内部实现(三)"><meta name=twitter:description content="
非线性 => 线性，混乱 => 秩序
上一篇博文主要写了Prometheus server的启动过程，但是并没有深入各个组件，了解其具体实现，这篇文件主要介绍Initial configuration loading部分。
Prometheus server的main函数有两个很精彩的实现，一个是reloader的注册，一个是组件启动。但是有个问题，所有的组件都是同时启动的吗？还是有什么顺序？
我们列一个组件清单：
- Termination handler.
- Scrape discovery manager.
- Notify discovery manager.
- Scrape manager.
- Reload handler.
- Rule manager.
- TSDB.
- Web handler.
- Notifier.
再来看一下组件启动使用的底层技术:

run.Group is a universal mechanism to manage goroutine lifecycles.
Create a zero-value run.Group, and then add actors to it. Actors are defined as a pair of functions: an execute function, which should run synchronously; and an interrupt function, which, when invoked, should cause the execute function to return. Finally, invoke Run, which concurrently runs all of the actors, waits until the first actor exits, invokes the interrupt functions, and finally returns control to the caller only once all actors have returned. This general-purpose API allows callers to model pretty much any runnable task, and achieve well-defined lifecycle semantics for the group."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://solaim.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Prometheus内部实现(三)","item":"https://solaim.github.io/posts/prometheus%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E4%B8%89/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Prometheus内部实现(三)","name":"Prometheus内部实现(三)","description":" 非线性 =\u0026gt; 线性，混乱 =\u0026gt; 秩序\n上一篇博文主要写了Prometheus server的启动过程，但是并没有深入各个组件，了解其具体实现，这篇文件主要介绍Initial configuration loading部分。\nPrometheus server的main函数有两个很精彩的实现，一个是reloader的注册，一个是组件启动。但是有个问题，所有的组件都是同时启动的吗？还是有什么顺序？\n我们列一个组件清单：\n- Termination handler. - Scrape discovery manager. - Notify discovery manager. - Scrape manager. - Reload handler. - Rule manager. - TSDB. - Web handler. - Notifier. 再来看一下组件启动使用的底层技术:\nrun.Group is a universal mechanism to manage goroutine lifecycles.\nCreate a zero-value run.Group, and then add actors to it. Actors are defined as a pair of functions: an execute function, which should run synchronously; and an interrupt function, which, when invoked, should cause the execute function to return. Finally, invoke Run, which concurrently runs all of the actors, waits until the first actor exits, invokes the interrupt functions, and finally returns control to the caller only once all actors have returned. This general-purpose API allows callers to model pretty much any runnable task, and achieve well-defined lifecycle semantics for the group.\n","keywords":["Golang","Prometheus","Observability"],"articleBody":" 非线性 =\u003e 线性，混乱 =\u003e 秩序\n上一篇博文主要写了Prometheus server的启动过程，但是并没有深入各个组件，了解其具体实现，这篇文件主要介绍Initial configuration loading部分。\nPrometheus server的main函数有两个很精彩的实现，一个是reloader的注册，一个是组件启动。但是有个问题，所有的组件都是同时启动的吗？还是有什么顺序？\n我们列一个组件清单：\n- Termination handler. - Scrape discovery manager. - Notify discovery manager. - Scrape manager. - Reload handler. - Rule manager. - TSDB. - Web handler. - Notifier. 再来看一下组件启动使用的底层技术:\nrun.Group is a universal mechanism to manage goroutine lifecycles.\nCreate a zero-value run.Group, and then add actors to it. Actors are defined as a pair of functions: an execute function, which should run synchronously; and an interrupt function, which, when invoked, should cause the execute function to return. Finally, invoke Run, which concurrently runs all of the actors, waits until the first actor exits, invokes the interrupt functions, and finally returns control to the caller only once all actors have returned. This general-purpose API allows callers to model pretty much any runnable task, and achieve well-defined lifecycle semantics for the group.\nrun.Group was written to manage component lifecycles in func main for OK Log. But it’s useful in any circumstance where you need to orchestrate multiple goroutines as a unit whole. Click here to see a video of a talk where run.Group is described.\nsource: https://pkg.go.dev/github.com/oklog/run\n简单总结一下，oklog/run库的run.Group实现了一种goroutine生命的管理机制，使用了actor模型，注册一对函数execute和interrupt。回忆一下上篇博客，实现正是如此。\nTermination handler组件的execute函数使用select等待term、webHandler、cancel的通知，用于保证系统正常退出，进入即阻塞。\nScrape discovery manager组件直接调用discoveryManagerScrape.Run。\nNotify discovery manager组件直接调用discoveryManagerNotify.Run。\nScrape manager组件等待reloadReady.C通知，然后运行scrapeManager.Run。\nReload handler组件等待reloadReady.C通知，然后等待hup、webHandler、cancel的通知，根据通知重新加载。\nInitial configuration loading组件进入后等待dbOpen、cancel通知，dbOpen通知后，加载配置。\nRule manager组件等待reloadReady.C通知，然后运行ruleManager.Run。\nTSDB组件运行openDBWithMetrics，然后close dbOpen channel。\nWeb handler组件直接调用webHandler.Run。\nNotifier组件等待reloadReady.C通知，然后调用notifierManager.Run。\n可以看出整个控制流程有两个很重要的channel：dbOpen和reloadReady.C。我们再看看这两个channel，\n// Start all components while we wait for TSDB to open but only load // initial config and mark ourselves as ready after it completed. dbOpen := make(chan struct{}) // sync.Once is used to make sure we can close the channel at different execution stages(SIGTERM or when the config is loaded). type closeOnce struct { C chan struct{} once sync.Once Close func() } // Wait until the server is ready to handle reloading. reloadReady := \u0026closeOnce{ C: make(chan struct{}), } reloadReady.Close = func() { reloadReady.once.Do(func() { close(reloadReady.C) }) } 根据上面的总结，Termination handler、Scrape discovery manager、Notify discovery manager、TSDB、Web handler组件直接运行，TSDB初始化结束后，关闭dbOpen channel，接着Initial configuration loading结束阻塞，开始运行，在某处关闭了reloadReady.C channel后，等待该channel通知的组件开始运行。\nInitial configuration loading组件的execute函数如下，可见最重要的就是reloadConfig函数的实现\nselect { case \u003c-dbOpen: // In case a shutdown is initiated before the dbOpen is released case \u003c-cancel: reloadReady.Close() return nil } if err := reloadConfig(cfg.configFile, logger, noStepSubqueryInterval, reloaders...); err != nil { return errors.Wrapf(err, \"error loading config from %q\", cfg.configFile) } reloadReady.Close() reloadConfig函数实现如下\nfunc reloadConfig(filename string, logger log.Logger, noStepSuqueryInterval *safePromQLNoStepSubqueryInterval, rls ...reloader) (err error) { start := time.Now() timings := []interface{}{} level.Info(logger).Log(\"msg\", \"Loading configuration file\", \"filename\", filename) defer func() { if err == nil { configSuccess.Set(1) configSuccessTime.SetToCurrentTime() } else { configSuccess.Set(0) } }() conf, err := config.LoadFile(filename) if err != nil { return errors.Wrapf(err, \"couldn't load configuration (--config.file=%q)\", filename) } failed := false for _, rl := range rls { rstart := time.Now() if err := rl.reloader(conf); err != nil { level.Error(logger).Log(\"msg\", \"Failed to apply configuration\", \"err\", err) failed = true } timings = append(timings, rl.name, time.Since(rstart)) } if failed { return errors.Errorf(\"one or more errors occurred while applying the new configuration (--config.file=%q)\", filename) } noStepSuqueryInterval.Set(conf.GlobalConfig.EvaluationInterval) l := []interface{}{\"msg\", \"Completed loading of configuration file\", \"filename\", filename, \"totalDuration\", time.Since(start)} level.Info(logger).Log(append(l, timings...)...) return nil } 该函数里面有两个重要功能，一个是解析配置文件，另一个是调用reloader。reloader的调用先不深究，我们留到下一篇讲scrape的时候再研究，这里先研究一下配置文件的解析，这个也是相当精彩的。配置文件的struct定义如下，\ntype Config struct { GlobalConfig GlobalConfig `yaml:\"global\"` AlertingConfig AlertingConfig `yaml:\"alerting,omitempty\"` RuleFiles []string `yaml:\"rule_files,omitempty\"` ScrapeConfigs []*ScrapeConfig `yaml:\"scrape_configs,omitempty\"` RemoteWriteConfigs []*RemoteWriteConfig `yaml:\"remote_write,omitempty\"` RemoteReadConfigs []*RemoteReadConfig `yaml:\"remote_read,omitempty\"` } 因为需要支持各种动态发现组件，ServiceDiscoveryConfigs在这里tag key为“-”，表示不解析，config.go自定义实现了UnmarshalYAML，用于解析配置\ntype ScrapeConfig struct { // The job name to which the job label is set by default. JobName string `yaml:\"job_name\"` // Indicator whether the scraped metrics should remain unmodified. HonorLabels bool `yaml:\"honor_labels,omitempty\"` // Indicator whether the scraped timestamps should be respected. HonorTimestamps bool `yaml:\"honor_timestamps\"` // A set of query parameters with which the target is scraped. Params url.Values `yaml:\"params,omitempty\"` // How frequently to scrape the targets of this scrape config. ScrapeInterval model.Duration `yaml:\"scrape_interval,omitempty\"` // The timeout for scraping targets of this config. ScrapeTimeout model.Duration `yaml:\"scrape_timeout,omitempty\"` // The HTTP resource path on which to fetch metrics from targets. MetricsPath string `yaml:\"metrics_path,omitempty\"` // The URL scheme with which to fetch metrics from targets. Scheme string `yaml:\"scheme,omitempty\"` // More than this many samples post metric-relabeling will cause the scrape to fail. SampleLimit uint `yaml:\"sample_limit,omitempty\"` // More than this many targets after the target relabeling will cause the // scrapes to fail. TargetLimit uint `yaml:\"target_limit,omitempty\"` // We cannot do proper Go type embedding below as the parser will then parse // values arbitrarily into the overflow maps of further-down types. ServiceDiscoveryConfigs discovery.Configs `yaml:\"-\"` HTTPClientConfig config.HTTPClientConfig `yaml:\",inline\"` // List of target relabel configurations. RelabelConfigs []*relabel.Config `yaml:\"relabel_configs,omitempty\"` // List of metric relabel configurations. MetricRelabelConfigs []*relabel.Config `yaml:\"metric_relabel_configs,omitempty\"` } conf, err := config.LoadFile(filename)这个调用返回一个Config指针，\nfunc Load(s string) (*Config, error) { cfg := \u0026Config{} // If the entire config body is empty the UnmarshalYAML method is // never called. We thus have to set the DefaultConfig at the entry // point as well. *cfg = DefaultConfig err := yaml.UnmarshalStrict([]byte(s), cfg) if err != nil { return nil, err } return cfg, nil } err := yaml.UnmarshalStrict([]byte(s), cfg)调用Config的yaml Unmarshal方法，解析配置，但是Prometheus自定义了整个配置文件的解析，Config的UnmarshalYAML实现如下：\nfunc (c *Config) UnmarshalYAML(unmarshal func(interface{}) error) error { *c = DefaultConfig // We want to set c to the defaults and then overwrite it with the input. // To make unmarshal fill the plain data struct rather than calling UnmarshalYAML // again, we have to hide it using a type indirection. type plain Config if err := unmarshal((*plain)(c)); err != nil { return err } // If a global block was open but empty the default global config is overwritten. // We have to restore it here. if c.GlobalConfig.isZero() { c.GlobalConfig = DefaultGlobalConfig } for _, rf := range c.RuleFiles { if !patRulePath.MatchString(rf) { return errors.Errorf(\"invalid rule file path %q\", rf) } } // Do global overrides and validate unique names. jobNames := map[string]struct{}{} for _, scfg := range c.ScrapeConfigs { if scfg == nil { return errors.New(\"empty or null scrape config section\") } // First set the correct scrape interval, then check that the timeout // (inferred or explicit) is not greater than that. if scfg.ScrapeInterval == 0 { scfg.ScrapeInterval = c.GlobalConfig.ScrapeInterval } if scfg.ScrapeTimeout \u003e scfg.ScrapeInterval { return errors.Errorf(\"scrape timeout greater than scrape interval for scrape config with job name %q\", scfg.JobName) } if scfg.ScrapeTimeout == 0 { if c.GlobalConfig.ScrapeTimeout \u003e scfg.ScrapeInterval { scfg.ScrapeTimeout = scfg.ScrapeInterval } else { scfg.ScrapeTimeout = c.GlobalConfig.ScrapeTimeout } } if _, ok := jobNames[scfg.JobName]; ok { return errors.Errorf(\"found multiple scrape configs with job name %q\", scfg.JobName) } jobNames[scfg.JobName] = struct{}{} } rwNames := map[string]struct{}{} for _, rwcfg := range c.RemoteWriteConfigs { if rwcfg == nil { return errors.New(\"empty or null remote write config section\") } // Skip empty names, we fill their name with their config hash in remote write code. if _, ok := rwNames[rwcfg.Name]; ok \u0026\u0026 rwcfg.Name != \"\" { return errors.Errorf(\"found multiple remote write configs with job name %q\", rwcfg.Name) } rwNames[rwcfg.Name] = struct{}{} } rrNames := map[string]struct{}{} for _, rrcfg := range c.RemoteReadConfigs { if rrcfg == nil { return errors.New(\"empty or null remote read config section\") } // Skip empty names, we fill their name with their config hash in remote read code. if _, ok := rrNames[rrcfg.Name]; ok \u0026\u0026 rrcfg.Name != \"\" { return errors.Errorf(\"found multiple remote read configs with job name %q\", rrcfg.Name) } rrNames[rrcfg.Name] = struct{}{} } return nil } 这个配置的解析和验证实在是太复杂了，我们不管其他struct field的unmarshal，关注scrape configs的解析，\nfunc (c *ScrapeConfig) UnmarshalYAML(unmarshal func(interface{}) error) error { *c = DefaultScrapeConfig if err := discovery.UnmarshalYAMLWithInlineConfigs(c, unmarshal); err != nil { return err } if len(c.JobName) == 0 { return errors.New(\"job_name is empty\") } // The UnmarshalYAML method of HTTPClientConfig is not being called because it's not a pointer. // We cannot make it a pointer as the parser panics for inlined pointer structs. // Thus we just do its validation here. if err := c.HTTPClientConfig.Validate(); err != nil { return err } // Check for users putting URLs in target groups. if len(c.RelabelConfigs) == 0 { if err := checkStaticTargets(c.ServiceDiscoveryConfigs); err != nil { return err } } for _, rlcfg := range c.RelabelConfigs { if rlcfg == nil { return errors.New(\"empty or null target relabeling rule in scrape config\") } } for _, rlcfg := range c.MetricRelabelConfigs { if rlcfg == nil { return errors.New(\"empty or null metric relabeling rule in scrape config\") } } return nil } err := discovery.UnmarshalYAMLWithInlineConfigs(c, unmarshal)里面是解析动态发现的具体实现， let us drill down：\nfunc UnmarshalYAMLWithInlineConfigs(out interface{}, unmarshal func(interface{}) error) error { outVal := reflect.ValueOf(out) if outVal.Kind() != reflect.Ptr { return fmt.Errorf(\"discovery: can only unmarshal into a struct pointer: %T\", out) } outVal = outVal.Elem() if outVal.Kind() != reflect.Struct { return fmt.Errorf(\"discovery: can only unmarshal into a struct pointer: %T\", out) } outTyp := outVal.Type() cfgTyp := getConfigType(outTyp) cfgPtr := reflect.New(cfgTyp) cfgVal := cfgPtr.Elem() // Copy shared fields (defaults) to dynamic value. var configs *Configs for i, n := 0, outVal.NumField(); i \u003c n; i++ { if outTyp.Field(i).Type == configsType { configs = outVal.Field(i).Addr().Interface().(*Configs) continue } if cfgTyp.Field(i).PkgPath != \"\" { continue // Field is unexported: ignore. } cfgVal.Field(i).Set(outVal.Field(i)) } if configs == nil { return fmt.Errorf(\"discovery: Configs field not found in type: %T\", out) } // Unmarshal into dynamic value. if err := unmarshal(cfgPtr.Interface()); err != nil { return replaceYAMLTypeError(err, cfgTyp, outTyp) } // Copy shared fields from dynamic value. for i, n := 0, outVal.NumField(); i \u003c n; i++ { if cfgTyp.Field(i).PkgPath != \"\" { continue // Field is unexported: ignore. } outVal.Field(i).Set(cfgVal.Field(i)) } var err error *configs, err = readConfigs(cfgVal, outVal.NumField()) return err } Oh, my god! 这个太刺激了，用reflect去实现底层的数据解析，这个以后要看看底层的实现，先不管了，我们看到上面函数的倒数第二句有这样一个调用*configs, err = readConfigs(cfgVal, outVal.NumField())，继续drill down\nfunc readConfigs(structVal reflect.Value, startField int) (Configs, error) { var ( configs Configs targets []*targetgroup.Group ) for i, n := startField, structVal.NumField(); i \u003c n; i++ { field := structVal.Field(i) if field.Kind() != reflect.Slice { panic(\"discovery: internal error: field is not a slice\") } for k := 0; k \u003c field.Len(); k++ { val := field.Index(k) if val.IsZero() || (val.Kind() == reflect.Ptr \u0026\u0026 val.Elem().IsZero()) { key := configFieldNames[field.Type().Elem()] key = strings.TrimPrefix(key, configFieldPrefix) return nil, fmt.Errorf(\"empty or null section in %s\", key) } switch c := val.Interface().(type) { case *targetgroup.Group: // Add index to the static config target groups for unique identification // within scrape pool. c.Source = strconv.Itoa(len(targets)) // Coalesce multiple static configs into a single static config. targets = append(targets, c) case Config: configs = append(configs, c) default: panic(\"discovery: internal error: slice element is not a Config\") } } } if len(targets) \u003e 0 { configs = append(configs, StaticConfig(targets)) } return configs, nil } 厉害了厉害了，我们终于解析完了scrape config，终于知道可以去抓取哪些目标metrics了。嗯，又有新目标，了解yaml底层解析的原理！！！\n下一篇我们接着研究Prometheus server的scrape实现。\n","wordCount":"1677","inLanguage":"en","image":"https://solaim.github.io/img/favicon.webp","datePublished":"2021-03-20T21:29:33+08:00","dateModified":"2021-03-20T21:29:33+08:00","author":{"@type":"Person","name":"Jerry Wang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://solaim.github.io/posts/prometheus%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E4%B8%89/"},"publisher":{"@type":"Organization","name":"Jerry Wang","logo":{"@type":"ImageObject","url":"https://solaim.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://solaim.github.io/ accesskey=h title="首页 (Alt + H)"><img src=https://solaim.github.io/apple-touch-icon.png alt aria-label=logo height=35>首页</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://solaim.github.io/categories/ title=🕸分类><span>🕸分类</span></a></li><li><a href=https://solaim.github.io/tags/ title=🐚标签><span>🐚标签</span></a></li><li><a href=https://solaim.github.io/about/ title=🌏关于><span>🌏关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://solaim.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://solaim.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Prometheus内部实现(三)</h1><div class=post-meta><span title='2021-03-20 21:29:33 +0800 +0800'>2021-03-20</span>&nbsp;·&nbsp;Jerry Wang</div></header><div class=post-content><blockquote><p>非线性 => 线性，混乱 => 秩序</p></blockquote><p>上一篇博文主要写了Prometheus server的启动过程，但是并没有深入各个组件，了解其具体实现，这篇文件主要介绍Initial configuration loading部分。</p><p>Prometheus server的main函数有两个很精彩的实现，一个是reloader的注册，一个是组件启动。但是有个问题，所有的组件都是同时启动的吗？还是有什么顺序？</p><p>我们列一个组件清单：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>- Termination handler.
</span></span><span class=line><span class=cl>- Scrape discovery manager.
</span></span><span class=line><span class=cl>- Notify discovery manager.
</span></span><span class=line><span class=cl>- Scrape manager.
</span></span><span class=line><span class=cl>- Reload handler.
</span></span><span class=line><span class=cl>- Rule manager.
</span></span><span class=line><span class=cl>- TSDB.
</span></span><span class=line><span class=cl>- Web handler.
</span></span><span class=line><span class=cl>- Notifier.
</span></span></code></pre></div><p>再来看一下组件启动使用的底层技术:</p><blockquote><p>run.Group is a universal mechanism to manage goroutine lifecycles.</p><p>Create a zero-value run.Group, and then add actors to it. Actors are defined as a pair of functions: an <strong>execute</strong> function, which should run synchronously; and an <strong>interrupt</strong> function, which, when invoked, should cause the execute function to return. Finally, invoke Run, which concurrently runs all of the actors, waits until the first actor exits, invokes the interrupt functions, and finally returns control to the caller only once all actors have returned. This general-purpose API allows callers to model pretty much any runnable task, and achieve well-defined lifecycle semantics for the group.</p><p>run.Group was written to manage component lifecycles in func main for <a href=https://github.com/oklog/oklog>OK Log</a>. But it&rsquo;s useful in any circumstance where you need to orchestrate multiple goroutines as a unit whole. <a href="https://www.youtube.com/watch?v=LHe1Cb_Ud_M&amp;t=15m45s">Click here</a> to see a video of a talk where run.Group is described.</p><p>source: <a href=https://pkg.go.dev/github.com/oklog/run>https://pkg.go.dev/github.com/oklog/run</a></p></blockquote><p>简单总结一下，oklog/run库的run.Group实现了一种goroutine生命的管理机制，使用了actor模型，注册一对函数execute和interrupt。回忆一下上篇博客，实现正是如此。</p><p>Termination handler组件的execute函数使用select等待term、webHandler、cancel的通知，用于保证系统正常退出，进入即阻塞。</p><p>Scrape discovery manager组件直接调用discoveryManagerScrape.Run。</p><p>Notify discovery manager组件直接调用discoveryManagerNotify.Run。</p><p>Scrape manager组件等待reloadReady.C通知，然后运行scrapeManager.Run。</p><p>Reload handler组件等待reloadReady.C通知，然后等待hup、webHandler、cancel的通知，根据通知重新加载。</p><p>Initial configuration loading组件进入后等待dbOpen、cancel通知，dbOpen通知后，加载配置。</p><p>Rule manager组件等待reloadReady.C通知，然后运行ruleManager.Run。</p><p>TSDB组件运行openDBWithMetrics，然后close dbOpen channel。</p><p>Web handler组件直接调用webHandler.Run。</p><p>Notifier组件等待reloadReady.C通知，然后调用notifierManager.Run。</p><p>可以看出整个控制流程有两个很重要的channel：dbOpen和reloadReady.C。我们再看看这两个channel，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Start all components while we wait for TSDB to open but only load</span>
</span></span><span class=line><span class=cl><span class=c1>// initial config and mark ourselves as ready after it completed.</span>
</span></span><span class=line><span class=cl><span class=nx>dbOpen</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// sync.Once is used to make sure we can close the channel at different execution stages(SIGTERM or when the config is loaded).</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>closeOnce</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>C</span>     <span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=nx>once</span>  <span class=nx>sync</span><span class=p>.</span><span class=nx>Once</span>
</span></span><span class=line><span class=cl>  <span class=nx>Close</span> <span class=kd>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// Wait until the server is ready to handle reloading.</span>
</span></span><span class=line><span class=cl><span class=nx>reloadReady</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>closeOnce</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>C</span><span class=p>:</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}),</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>reloadReady</span><span class=p>.</span><span class=nx>Close</span> <span class=p>=</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>reloadReady</span><span class=p>.</span><span class=nx>once</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>close</span><span class=p>(</span><span class=nx>reloadReady</span><span class=p>.</span><span class=nx>C</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>根据上面的总结，Termination handler、Scrape discovery manager、Notify discovery manager、TSDB、Web handler组件直接运行，TSDB初始化结束后，关闭dbOpen channel，接着Initial configuration loading结束阻塞，开始运行，在某处关闭了reloadReady.C channel后，等待该channel通知的组件开始运行。</p><p>Initial configuration loading组件的execute函数如下，可见最重要的就是reloadConfig函数的实现</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>dbOpen</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>// In case a shutdown is initiated before the dbOpen is released</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>cancel</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=nx>reloadReady</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>reloadConfig</span><span class=p>(</span><span class=nx>cfg</span><span class=p>.</span><span class=nx>configFile</span><span class=p>,</span> <span class=nx>logger</span><span class=p>,</span> <span class=nx>noStepSubqueryInterval</span><span class=p>,</span> <span class=nx>reloaders</span><span class=o>...</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Wrapf</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=s>&#34;error loading config from %q&#34;</span><span class=p>,</span> <span class=nx>cfg</span><span class=p>.</span><span class=nx>configFile</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>reloadReady</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span></code></pre></div><p>reloadConfig函数实现如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>reloadConfig</span><span class=p>(</span><span class=nx>filename</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>logger</span> <span class=nx>log</span><span class=p>.</span><span class=nx>Logger</span><span class=p>,</span> <span class=nx>noStepSuqueryInterval</span> <span class=o>*</span><span class=nx>safePromQLNoStepSubqueryInterval</span><span class=p>,</span> <span class=nx>rls</span> <span class=o>...</span><span class=nx>reloader</span><span class=p>)</span> <span class=p>(</span><span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>start</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=nx>timings</span> <span class=o>:=</span> <span class=p>[]</span><span class=kd>interface</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>  <span class=nx>level</span><span class=p>.</span><span class=nf>Info</span><span class=p>(</span><span class=nx>logger</span><span class=p>).</span><span class=nf>Log</span><span class=p>(</span><span class=s>&#34;msg&#34;</span><span class=p>,</span> <span class=s>&#34;Loading configuration file&#34;</span><span class=p>,</span> <span class=s>&#34;filename&#34;</span><span class=p>,</span> <span class=nx>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>configSuccess</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nx>configSuccessTime</span><span class=p>.</span><span class=nf>SetToCurrentTime</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>configSuccess</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>conf</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>config</span><span class=p>.</span><span class=nf>LoadFile</span><span class=p>(</span><span class=nx>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Wrapf</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=s>&#34;couldn&#39;t load configuration (--config.file=%q)&#34;</span><span class=p>,</span> <span class=nx>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>failed</span> <span class=o>:=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>rl</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>rls</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>rstart</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rl</span><span class=p>.</span><span class=nf>reloader</span><span class=p>(</span><span class=nx>conf</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>level</span><span class=p>.</span><span class=nf>Error</span><span class=p>(</span><span class=nx>logger</span><span class=p>).</span><span class=nf>Log</span><span class=p>(</span><span class=s>&#34;msg&#34;</span><span class=p>,</span> <span class=s>&#34;Failed to apply configuration&#34;</span><span class=p>,</span> <span class=s>&#34;err&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nx>failed</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>timings</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>timings</span><span class=p>,</span> <span class=nx>rl</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Since</span><span class=p>(</span><span class=nx>rstart</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>failed</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;one or more errors occurred while applying the new configuration (--config.file=%q)&#34;</span><span class=p>,</span> <span class=nx>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>noStepSuqueryInterval</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=nx>conf</span><span class=p>.</span><span class=nx>GlobalConfig</span><span class=p>.</span><span class=nx>EvaluationInterval</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>l</span> <span class=o>:=</span> <span class=p>[]</span><span class=kd>interface</span><span class=p>{}{</span><span class=s>&#34;msg&#34;</span><span class=p>,</span> <span class=s>&#34;Completed loading of configuration file&#34;</span><span class=p>,</span> <span class=s>&#34;filename&#34;</span><span class=p>,</span> <span class=nx>filename</span><span class=p>,</span> <span class=s>&#34;totalDuration&#34;</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Since</span><span class=p>(</span><span class=nx>start</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>  <span class=nx>level</span><span class=p>.</span><span class=nf>Info</span><span class=p>(</span><span class=nx>logger</span><span class=p>).</span><span class=nf>Log</span><span class=p>(</span><span class=nb>append</span><span class=p>(</span><span class=nx>l</span><span class=p>,</span> <span class=nx>timings</span><span class=o>...</span><span class=p>)</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>该函数里面有两个重要功能，一个是解析配置文件，另一个是调用reloader。reloader的调用先不深究，我们留到下一篇讲scrape的时候再研究，这里先研究一下配置文件的解析，这个也是相当精彩的。配置文件的struct定义如下，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Config</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>GlobalConfig</span>   <span class=nx>GlobalConfig</span>    <span class=s>`yaml:&#34;global&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=nx>AlertingConfig</span> <span class=nx>AlertingConfig</span>  <span class=s>`yaml:&#34;alerting,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=nx>RuleFiles</span>      <span class=p>[]</span><span class=kt>string</span>        <span class=s>`yaml:&#34;rule_files,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=nx>ScrapeConfigs</span>  <span class=p>[]</span><span class=o>*</span><span class=nx>ScrapeConfig</span> <span class=s>`yaml:&#34;scrape_configs,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>RemoteWriteConfigs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>RemoteWriteConfig</span> <span class=s>`yaml:&#34;remote_write,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=nx>RemoteReadConfigs</span>  <span class=p>[]</span><span class=o>*</span><span class=nx>RemoteReadConfig</span>  <span class=s>`yaml:&#34;remote_read,omitempty&#34;`</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>因为需要支持各种动态发现组件，ServiceDiscoveryConfigs在这里tag key为“-”，表示不解析，config.go自定义实现了UnmarshalYAML，用于解析配置</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ScrapeConfig</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// The job name to which the job label is set by default.</span>
</span></span><span class=line><span class=cl>	<span class=nx>JobName</span> <span class=kt>string</span> <span class=s>`yaml:&#34;job_name&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Indicator whether the scraped metrics should remain unmodified.</span>
</span></span><span class=line><span class=cl>	<span class=nx>HonorLabels</span> <span class=kt>bool</span> <span class=s>`yaml:&#34;honor_labels,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Indicator whether the scraped timestamps should be respected.</span>
</span></span><span class=line><span class=cl>	<span class=nx>HonorTimestamps</span> <span class=kt>bool</span> <span class=s>`yaml:&#34;honor_timestamps&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=c1>// A set of query parameters with which the target is scraped.</span>
</span></span><span class=line><span class=cl>	<span class=nx>Params</span> <span class=nx>url</span><span class=p>.</span><span class=nx>Values</span> <span class=s>`yaml:&#34;params,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=c1>// How frequently to scrape the targets of this scrape config.</span>
</span></span><span class=line><span class=cl>	<span class=nx>ScrapeInterval</span> <span class=nx>model</span><span class=p>.</span><span class=nx>Duration</span> <span class=s>`yaml:&#34;scrape_interval,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=c1>// The timeout for scraping targets of this config.</span>
</span></span><span class=line><span class=cl>	<span class=nx>ScrapeTimeout</span> <span class=nx>model</span><span class=p>.</span><span class=nx>Duration</span> <span class=s>`yaml:&#34;scrape_timeout,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=c1>// The HTTP resource path on which to fetch metrics from targets.</span>
</span></span><span class=line><span class=cl>	<span class=nx>MetricsPath</span> <span class=kt>string</span> <span class=s>`yaml:&#34;metrics_path,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=c1>// The URL scheme with which to fetch metrics from targets.</span>
</span></span><span class=line><span class=cl>	<span class=nx>Scheme</span> <span class=kt>string</span> <span class=s>`yaml:&#34;scheme,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=c1>// More than this many samples post metric-relabeling will cause the scrape to fail.</span>
</span></span><span class=line><span class=cl>	<span class=nx>SampleLimit</span> <span class=kt>uint</span> <span class=s>`yaml:&#34;sample_limit,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=c1>// More than this many targets after the target relabeling will cause the</span>
</span></span><span class=line><span class=cl>	<span class=c1>// scrapes to fail.</span>
</span></span><span class=line><span class=cl>	<span class=nx>TargetLimit</span> <span class=kt>uint</span> <span class=s>`yaml:&#34;target_limit,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// We cannot do proper Go type embedding below as the parser will then parse</span>
</span></span><span class=line><span class=cl>	<span class=c1>// values arbitrarily into the overflow maps of further-down types.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>ServiceDiscoveryConfigs</span> <span class=nx>discovery</span><span class=p>.</span><span class=nx>Configs</span>       <span class=s>`yaml:&#34;-&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=nx>HTTPClientConfig</span>        <span class=nx>config</span><span class=p>.</span><span class=nx>HTTPClientConfig</span> <span class=s>`yaml:&#34;,inline&#34;`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// List of target relabel configurations.</span>
</span></span><span class=line><span class=cl>	<span class=nx>RelabelConfigs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>relabel</span><span class=p>.</span><span class=nx>Config</span> <span class=s>`yaml:&#34;relabel_configs,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=c1>// List of metric relabel configurations.</span>
</span></span><span class=line><span class=cl>	<span class=nx>MetricRelabelConfigs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>relabel</span><span class=p>.</span><span class=nx>Config</span> <span class=s>`yaml:&#34;metric_relabel_configs,omitempty&#34;`</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>conf, err := config.LoadFile(filename)</code>这个调用返回一个Config指针，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Load</span><span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>Config</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>cfg</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Config</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// If the entire config body is empty the UnmarshalYAML method is</span>
</span></span><span class=line><span class=cl>  <span class=c1>// never called. We thus have to set the DefaultConfig at the entry</span>
</span></span><span class=line><span class=cl>  <span class=c1>// point as well.</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=nx>cfg</span> <span class=p>=</span> <span class=nx>DefaultConfig</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>err</span> <span class=o>:=</span> <span class=nx>yaml</span><span class=p>.</span><span class=nf>UnmarshalStrict</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>s</span><span class=p>),</span> <span class=nx>cfg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>cfg</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>err := yaml.UnmarshalStrict([]byte(s), cfg)</code>调用Config的yaml Unmarshal方法，解析配置，但是Prometheus自定义了整个配置文件的解析，Config的UnmarshalYAML实现如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>Config</span><span class=p>)</span> <span class=nf>UnmarshalYAML</span><span class=p>(</span><span class=nx>unmarshal</span> <span class=kd>func</span><span class=p>(</span><span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=nx>c</span> <span class=p>=</span> <span class=nx>DefaultConfig</span>
</span></span><span class=line><span class=cl>  <span class=c1>// We want to set c to the defaults and then overwrite it with the input.</span>
</span></span><span class=line><span class=cl>  <span class=c1>// To make unmarshal fill the plain data struct rather than calling UnmarshalYAML</span>
</span></span><span class=line><span class=cl>  <span class=c1>// again, we have to hide it using a type indirection.</span>
</span></span><span class=line><span class=cl>  <span class=kd>type</span> <span class=nx>plain</span> <span class=nx>Config</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>unmarshal</span><span class=p>((</span><span class=o>*</span><span class=nx>plain</span><span class=p>)(</span><span class=nx>c</span><span class=p>));</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// If a global block was open but empty the default global config is overwritten.</span>
</span></span><span class=line><span class=cl>  <span class=c1>// We have to restore it here.</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>GlobalConfig</span><span class=p>.</span><span class=nf>isZero</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span><span class=p>.</span><span class=nx>GlobalConfig</span> <span class=p>=</span> <span class=nx>DefaultGlobalConfig</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>rf</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span><span class=p>.</span><span class=nx>RuleFiles</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>!</span><span class=nx>patRulePath</span><span class=p>.</span><span class=nf>MatchString</span><span class=p>(</span><span class=nx>rf</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;invalid rule file path %q&#34;</span><span class=p>,</span> <span class=nx>rf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Do global overrides and validate unique names.</span>
</span></span><span class=line><span class=cl>  <span class=nx>jobNames</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>scfg</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span><span class=p>.</span><span class=nx>ScrapeConfigs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>scfg</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;empty or null scrape config section&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// First set the correct scrape interval, then check that the timeout</span>
</span></span><span class=line><span class=cl>    <span class=c1>// (inferred or explicit) is not greater than that.</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>scfg</span><span class=p>.</span><span class=nx>ScrapeInterval</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>scfg</span><span class=p>.</span><span class=nx>ScrapeInterval</span> <span class=p>=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>GlobalConfig</span><span class=p>.</span><span class=nx>ScrapeInterval</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>scfg</span><span class=p>.</span><span class=nx>ScrapeTimeout</span> <span class=p>&gt;</span> <span class=nx>scfg</span><span class=p>.</span><span class=nx>ScrapeInterval</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;scrape timeout greater than scrape interval for scrape config with job name %q&#34;</span><span class=p>,</span> <span class=nx>scfg</span><span class=p>.</span><span class=nx>JobName</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>scfg</span><span class=p>.</span><span class=nx>ScrapeTimeout</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>GlobalConfig</span><span class=p>.</span><span class=nx>ScrapeTimeout</span> <span class=p>&gt;</span> <span class=nx>scfg</span><span class=p>.</span><span class=nx>ScrapeInterval</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>scfg</span><span class=p>.</span><span class=nx>ScrapeTimeout</span> <span class=p>=</span> <span class=nx>scfg</span><span class=p>.</span><span class=nx>ScrapeInterval</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>scfg</span><span class=p>.</span><span class=nx>ScrapeTimeout</span> <span class=p>=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>GlobalConfig</span><span class=p>.</span><span class=nx>ScrapeTimeout</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>jobNames</span><span class=p>[</span><span class=nx>scfg</span><span class=p>.</span><span class=nx>JobName</span><span class=p>];</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;found multiple scrape configs with job name %q&#34;</span><span class=p>,</span> <span class=nx>scfg</span><span class=p>.</span><span class=nx>JobName</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>jobNames</span><span class=p>[</span><span class=nx>scfg</span><span class=p>.</span><span class=nx>JobName</span><span class=p>]</span> <span class=p>=</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nx>rwNames</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>rwcfg</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span><span class=p>.</span><span class=nx>RemoteWriteConfigs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>rwcfg</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;empty or null remote write config section&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Skip empty names, we fill their name with their config hash in remote write code.</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>rwNames</span><span class=p>[</span><span class=nx>rwcfg</span><span class=p>.</span><span class=nx>Name</span><span class=p>];</span> <span class=nx>ok</span> <span class=o>&amp;&amp;</span> <span class=nx>rwcfg</span><span class=p>.</span><span class=nx>Name</span> <span class=o>!=</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;found multiple remote write configs with job name %q&#34;</span><span class=p>,</span> <span class=nx>rwcfg</span><span class=p>.</span><span class=nx>Name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>rwNames</span><span class=p>[</span><span class=nx>rwcfg</span><span class=p>.</span><span class=nx>Name</span><span class=p>]</span> <span class=p>=</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nx>rrNames</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>rrcfg</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span><span class=p>.</span><span class=nx>RemoteReadConfigs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>rrcfg</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;empty or null remote read config section&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Skip empty names, we fill their name with their config hash in remote read code.</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>rrNames</span><span class=p>[</span><span class=nx>rrcfg</span><span class=p>.</span><span class=nx>Name</span><span class=p>];</span> <span class=nx>ok</span> <span class=o>&amp;&amp;</span> <span class=nx>rrcfg</span><span class=p>.</span><span class=nx>Name</span> <span class=o>!=</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;found multiple remote read configs with job name %q&#34;</span><span class=p>,</span> <span class=nx>rrcfg</span><span class=p>.</span><span class=nx>Name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>rrNames</span><span class=p>[</span><span class=nx>rrcfg</span><span class=p>.</span><span class=nx>Name</span><span class=p>]</span> <span class=p>=</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这个配置的解析和验证实在是太复杂了，我们不管其他struct field的unmarshal，关注scrape configs的解析，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>ScrapeConfig</span><span class=p>)</span> <span class=nf>UnmarshalYAML</span><span class=p>(</span><span class=nx>unmarshal</span> <span class=kd>func</span><span class=p>(</span><span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=nx>c</span> <span class=p>=</span> <span class=nx>DefaultScrapeConfig</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>discovery</span><span class=p>.</span><span class=nf>UnmarshalYAMLWithInlineConfigs</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>unmarshal</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>JobName</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;job_name is empty&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// The UnmarshalYAML method of HTTPClientConfig is not being called because it&#39;s not a pointer.</span>
</span></span><span class=line><span class=cl>  <span class=c1>// We cannot make it a pointer as the parser panics for inlined pointer structs.</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Thus we just do its validation here.</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>HTTPClientConfig</span><span class=p>.</span><span class=nf>Validate</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Check for users putting URLs in target groups.</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>RelabelConfigs</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>checkStaticTargets</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>ServiceDiscoveryConfigs</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>rlcfg</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span><span class=p>.</span><span class=nx>RelabelConfigs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>rlcfg</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;empty or null target relabeling rule in scrape config&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>rlcfg</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span><span class=p>.</span><span class=nx>MetricRelabelConfigs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>rlcfg</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;empty or null metric relabeling rule in scrape config&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>err := discovery.UnmarshalYAMLWithInlineConfigs(c, unmarshal)</code>里面是解析动态发现的具体实现， let us drill down：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>UnmarshalYAMLWithInlineConfigs</span><span class=p>(</span><span class=nx>out</span> <span class=kd>interface</span><span class=p>{},</span> <span class=nx>unmarshal</span> <span class=kd>func</span><span class=p>(</span><span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>outVal</span> <span class=o>:=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>ValueOf</span><span class=p>(</span><span class=nx>out</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>outVal</span><span class=p>.</span><span class=nf>Kind</span><span class=p>()</span> <span class=o>!=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Ptr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;discovery: can only unmarshal into a struct pointer: %T&#34;</span><span class=p>,</span> <span class=nx>out</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nx>outVal</span> <span class=p>=</span> <span class=nx>outVal</span><span class=p>.</span><span class=nf>Elem</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>outVal</span><span class=p>.</span><span class=nf>Kind</span><span class=p>()</span> <span class=o>!=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;discovery: can only unmarshal into a struct pointer: %T&#34;</span><span class=p>,</span> <span class=nx>out</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nx>outTyp</span> <span class=o>:=</span> <span class=nx>outVal</span><span class=p>.</span><span class=nf>Type</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>cfgTyp</span> <span class=o>:=</span> <span class=nf>getConfigType</span><span class=p>(</span><span class=nx>outTyp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>cfgPtr</span> <span class=o>:=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=nx>cfgTyp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>cfgVal</span> <span class=o>:=</span> <span class=nx>cfgPtr</span><span class=p>.</span><span class=nf>Elem</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Copy shared fields (defaults) to dynamic value.</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>configs</span> <span class=o>*</span><span class=nx>Configs</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>n</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>outVal</span><span class=p>.</span><span class=nf>NumField</span><span class=p>();</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>outTyp</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>).</span><span class=nx>Type</span> <span class=o>==</span> <span class=nx>configsType</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>configs</span> <span class=p>=</span> <span class=nx>outVal</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>).</span><span class=nf>Addr</span><span class=p>().</span><span class=nf>Interface</span><span class=p>().(</span><span class=o>*</span><span class=nx>Configs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>continue</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>cfgTyp</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>).</span><span class=nx>PkgPath</span> <span class=o>!=</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>continue</span> <span class=c1>// Field is unexported: ignore.</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>cfgVal</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>).</span><span class=nf>Set</span><span class=p>(</span><span class=nx>outVal</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>configs</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;discovery: Configs field not found in type: %T&#34;</span><span class=p>,</span> <span class=nx>out</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Unmarshal into dynamic value.</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>unmarshal</span><span class=p>(</span><span class=nx>cfgPtr</span><span class=p>.</span><span class=nf>Interface</span><span class=p>());</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>replaceYAMLTypeError</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=nx>cfgTyp</span><span class=p>,</span> <span class=nx>outTyp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Copy shared fields from dynamic value.</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>n</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>outVal</span><span class=p>.</span><span class=nf>NumField</span><span class=p>();</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>cfgTyp</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>).</span><span class=nx>PkgPath</span> <span class=o>!=</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>continue</span> <span class=c1>// Field is unexported: ignore.</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>outVal</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>).</span><span class=nf>Set</span><span class=p>(</span><span class=nx>cfgVal</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>err</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=nx>configs</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nf>readConfigs</span><span class=p>(</span><span class=nx>cfgVal</span><span class=p>,</span> <span class=nx>outVal</span><span class=p>.</span><span class=nf>NumField</span><span class=p>())</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Oh, my god! 这个太刺激了，用reflect去实现底层的数据解析，这个以后要看看底层的实现，先不管了，我们看到上面函数的倒数第二句有这样一个调用<code>*configs, err = readConfigs(cfgVal, outVal.NumField())</code>，继续drill down</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>readConfigs</span><span class=p>(</span><span class=nx>structVal</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Value</span><span class=p>,</span> <span class=nx>startField</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>Configs</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>configs</span> <span class=nx>Configs</span>
</span></span><span class=line><span class=cl>    <span class=nx>targets</span> <span class=p>[]</span><span class=o>*</span><span class=nx>targetgroup</span><span class=p>.</span><span class=nx>Group</span>
</span></span><span class=line><span class=cl>  <span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>n</span> <span class=o>:=</span> <span class=nx>startField</span><span class=p>,</span> <span class=nx>structVal</span><span class=p>.</span><span class=nf>NumField</span><span class=p>();</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>field</span> <span class=o>:=</span> <span class=nx>structVal</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>field</span><span class=p>.</span><span class=nf>Kind</span><span class=p>()</span> <span class=o>!=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Slice</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nb>panic</span><span class=p>(</span><span class=s>&#34;discovery: internal error: field is not a slice&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>k</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>k</span> <span class=p>&lt;</span> <span class=nx>field</span><span class=p>.</span><span class=nf>Len</span><span class=p>();</span> <span class=nx>k</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>val</span> <span class=o>:=</span> <span class=nx>field</span><span class=p>.</span><span class=nf>Index</span><span class=p>(</span><span class=nx>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nx>val</span><span class=p>.</span><span class=nf>IsZero</span><span class=p>()</span> <span class=o>||</span> <span class=p>(</span><span class=nx>val</span><span class=p>.</span><span class=nf>Kind</span><span class=p>()</span> <span class=o>==</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Ptr</span> <span class=o>&amp;&amp;</span> <span class=nx>val</span><span class=p>.</span><span class=nf>Elem</span><span class=p>().</span><span class=nf>IsZero</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>key</span> <span class=o>:=</span> <span class=nx>configFieldNames</span><span class=p>[</span><span class=nx>field</span><span class=p>.</span><span class=nf>Type</span><span class=p>().</span><span class=nf>Elem</span><span class=p>()]</span>
</span></span><span class=line><span class=cl>        <span class=nx>key</span> <span class=p>=</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>TrimPrefix</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>configFieldPrefix</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;empty or null section in %s&#34;</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=k>switch</span> <span class=nx>c</span> <span class=o>:=</span> <span class=nx>val</span><span class=p>.</span><span class=nf>Interface</span><span class=p>().(</span><span class=kd>type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=o>*</span><span class=nx>targetgroup</span><span class=p>.</span><span class=nx>Group</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Add index to the static config target groups for unique identification</span>
</span></span><span class=line><span class=cl>        <span class=c1>// within scrape pool.</span>
</span></span><span class=line><span class=cl>        <span class=nx>c</span><span class=p>.</span><span class=nx>Source</span> <span class=p>=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>Itoa</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>targets</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Coalesce multiple static configs into a single static config.</span>
</span></span><span class=line><span class=cl>        <span class=nx>targets</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>targets</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nx>Config</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nx>configs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>configs</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=s>&#34;discovery: internal error: slice element is not a Config&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>targets</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>configs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>configs</span><span class=p>,</span> <span class=nf>StaticConfig</span><span class=p>(</span><span class=nx>targets</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>configs</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>厉害了厉害了，我们终于解析完了scrape config，终于知道可以去抓取哪些目标metrics了。嗯，又有新目标，了解yaml底层解析的原理！！！</p><p>下一篇我们接着研究Prometheus server的scrape实现。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://solaim.github.io/tags/golang/>Golang</a></li><li><a href=https://solaim.github.io/tags/prometheus/>Prometheus</a></li><li><a href=https://solaim.github.io/tags/observability/>Observability</a></li></ul><nav class=paginav><a class=prev href=https://solaim.github.io/posts/prometheus%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%9B%9B/><span class=title>« Prev</span><br><span>Prometheus内部实现(四)</span>
</a><a class=next href=https://solaim.github.io/posts/prometheus%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E4%BA%8C/><span class=title>Next »</span><br><span>Prometheus内部实现(二)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://solaim.github.io/>Jerry Wang</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>