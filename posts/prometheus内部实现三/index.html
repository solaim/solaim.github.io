<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Prometheuså†…éƒ¨å®ç°(ä¸‰) | Jerry Wang</title>
<meta name=keywords content="Golang,Prometheus,Observability"><meta name=description content="
éçº¿æ€§ => çº¿æ€§ï¼Œæ··ä¹± => ç§©åº
ä¸Šä¸€ç¯‡åšæ–‡ä¸»è¦å†™äº†Prometheus serverçš„å¯åŠ¨è¿‡ç¨‹ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰æ·±å…¥å„ä¸ªç»„ä»¶ï¼Œäº†è§£å…¶å…·ä½“å®ç°ï¼Œè¿™ç¯‡æ–‡ä»¶ä¸»è¦ä»‹ç»Initial configuration loadingéƒ¨åˆ†ã€‚
Prometheus serverçš„mainå‡½æ•°æœ‰ä¸¤ä¸ªå¾ˆç²¾å½©çš„å®ç°ï¼Œä¸€ä¸ªæ˜¯reloaderçš„æ³¨å†Œï¼Œä¸€ä¸ªæ˜¯ç»„ä»¶å¯åŠ¨ã€‚ä½†æ˜¯æœ‰ä¸ªé—®é¢˜ï¼Œæ‰€æœ‰çš„ç»„ä»¶éƒ½æ˜¯åŒæ—¶å¯åŠ¨çš„å—ï¼Ÿè¿˜æ˜¯æœ‰ä»€ä¹ˆé¡ºåºï¼Ÿ
æˆ‘ä»¬åˆ—ä¸€ä¸ªç»„ä»¶æ¸…å•ï¼š
- Termination handler.
- Scrape discovery manager.
- Notify discovery manager.
- Scrape manager.
- Reload handler.
- Rule manager.
- TSDB.
- Web handler.
- Notifier.
å†æ¥çœ‹ä¸€ä¸‹ç»„ä»¶å¯åŠ¨ä½¿ç”¨çš„åº•å±‚æŠ€æœ¯:

run.Group is a universal mechanism to manage goroutine lifecycles.
Create a zero-value run.Group, and then add actors to it. Actors are defined as a pair of functions: an execute function, which should run synchronously; and an interrupt function, which, when invoked, should cause the execute function to return. Finally, invoke Run, which concurrently runs all of the actors, waits until the first actor exits, invokes the interrupt functions, and finally returns control to the caller only once all actors have returned. This general-purpose API allows callers to model pretty much any runnable task, and achieve well-defined lifecycle semantics for the group."><meta name=author content="Jerry Wang"><link rel=canonical href=https://solaim.github.io/posts/prometheus%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E4%B8%89/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://solaim.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://solaim.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://solaim.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://solaim.github.io/apple-touch-icon.png><link rel=mask-icon href=https://solaim.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://solaim.github.io/posts/prometheus%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E4%B8%89/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://solaim.github.io/posts/prometheus%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E4%B8%89/"><meta property="og:site_name" content="Jerry Wang"><meta property="og:title" content="Prometheuså†…éƒ¨å®ç°(ä¸‰)"><meta property="og:description" content=" éçº¿æ€§ => çº¿æ€§ï¼Œæ··ä¹± => ç§©åº
ä¸Šä¸€ç¯‡åšæ–‡ä¸»è¦å†™äº†Prometheus serverçš„å¯åŠ¨è¿‡ç¨‹ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰æ·±å…¥å„ä¸ªç»„ä»¶ï¼Œäº†è§£å…¶å…·ä½“å®ç°ï¼Œè¿™ç¯‡æ–‡ä»¶ä¸»è¦ä»‹ç»Initial configuration loadingéƒ¨åˆ†ã€‚
Prometheus serverçš„mainå‡½æ•°æœ‰ä¸¤ä¸ªå¾ˆç²¾å½©çš„å®ç°ï¼Œä¸€ä¸ªæ˜¯reloaderçš„æ³¨å†Œï¼Œä¸€ä¸ªæ˜¯ç»„ä»¶å¯åŠ¨ã€‚ä½†æ˜¯æœ‰ä¸ªé—®é¢˜ï¼Œæ‰€æœ‰çš„ç»„ä»¶éƒ½æ˜¯åŒæ—¶å¯åŠ¨çš„å—ï¼Ÿè¿˜æ˜¯æœ‰ä»€ä¹ˆé¡ºåºï¼Ÿ
æˆ‘ä»¬åˆ—ä¸€ä¸ªç»„ä»¶æ¸…å•ï¼š
- Termination handler. - Scrape discovery manager. - Notify discovery manager. - Scrape manager. - Reload handler. - Rule manager. - TSDB. - Web handler. - Notifier. å†æ¥çœ‹ä¸€ä¸‹ç»„ä»¶å¯åŠ¨ä½¿ç”¨çš„åº•å±‚æŠ€æœ¯:
run.Group is a universal mechanism to manage goroutine lifecycles.
Create a zero-value run.Group, and then add actors to it. Actors are defined as a pair of functions: an execute function, which should run synchronously; and an interrupt function, which, when invoked, should cause the execute function to return. Finally, invoke Run, which concurrently runs all of the actors, waits until the first actor exits, invokes the interrupt functions, and finally returns control to the caller only once all actors have returned. This general-purpose API allows callers to model pretty much any runnable task, and achieve well-defined lifecycle semantics for the group."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-20T21:29:33+08:00"><meta property="article:modified_time" content="2021-03-20T21:29:33+08:00"><meta property="article:tag" content="Golang"><meta property="article:tag" content="Prometheus"><meta property="article:tag" content="Observability"><meta property="og:image" content="https://solaim.github.io/img/favicon.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://solaim.github.io/img/favicon.webp"><meta name=twitter:title content="Prometheuså†…éƒ¨å®ç°(ä¸‰)"><meta name=twitter:description content="
éçº¿æ€§ => çº¿æ€§ï¼Œæ··ä¹± => ç§©åº
ä¸Šä¸€ç¯‡åšæ–‡ä¸»è¦å†™äº†Prometheus serverçš„å¯åŠ¨è¿‡ç¨‹ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰æ·±å…¥å„ä¸ªç»„ä»¶ï¼Œäº†è§£å…¶å…·ä½“å®ç°ï¼Œè¿™ç¯‡æ–‡ä»¶ä¸»è¦ä»‹ç»Initial configuration loadingéƒ¨åˆ†ã€‚
Prometheus serverçš„mainå‡½æ•°æœ‰ä¸¤ä¸ªå¾ˆç²¾å½©çš„å®ç°ï¼Œä¸€ä¸ªæ˜¯reloaderçš„æ³¨å†Œï¼Œä¸€ä¸ªæ˜¯ç»„ä»¶å¯åŠ¨ã€‚ä½†æ˜¯æœ‰ä¸ªé—®é¢˜ï¼Œæ‰€æœ‰çš„ç»„ä»¶éƒ½æ˜¯åŒæ—¶å¯åŠ¨çš„å—ï¼Ÿè¿˜æ˜¯æœ‰ä»€ä¹ˆé¡ºåºï¼Ÿ
æˆ‘ä»¬åˆ—ä¸€ä¸ªç»„ä»¶æ¸…å•ï¼š
- Termination handler.
- Scrape discovery manager.
- Notify discovery manager.
- Scrape manager.
- Reload handler.
- Rule manager.
- TSDB.
- Web handler.
- Notifier.
å†æ¥çœ‹ä¸€ä¸‹ç»„ä»¶å¯åŠ¨ä½¿ç”¨çš„åº•å±‚æŠ€æœ¯:

run.Group is a universal mechanism to manage goroutine lifecycles.
Create a zero-value run.Group, and then add actors to it. Actors are defined as a pair of functions: an execute function, which should run synchronously; and an interrupt function, which, when invoked, should cause the execute function to return. Finally, invoke Run, which concurrently runs all of the actors, waits until the first actor exits, invokes the interrupt functions, and finally returns control to the caller only once all actors have returned. This general-purpose API allows callers to model pretty much any runnable task, and achieve well-defined lifecycle semantics for the group."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://solaim.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Prometheuså†…éƒ¨å®ç°(ä¸‰)","item":"https://solaim.github.io/posts/prometheus%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E4%B8%89/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Prometheuså†…éƒ¨å®ç°(ä¸‰)","name":"Prometheuså†…éƒ¨å®ç°(ä¸‰)","description":" éçº¿æ€§ =\u0026gt; çº¿æ€§ï¼Œæ··ä¹± =\u0026gt; ç§©åº\nä¸Šä¸€ç¯‡åšæ–‡ä¸»è¦å†™äº†Prometheus serverçš„å¯åŠ¨è¿‡ç¨‹ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰æ·±å…¥å„ä¸ªç»„ä»¶ï¼Œäº†è§£å…¶å…·ä½“å®ç°ï¼Œè¿™ç¯‡æ–‡ä»¶ä¸»è¦ä»‹ç»Initial configuration loadingéƒ¨åˆ†ã€‚\nPrometheus serverçš„mainå‡½æ•°æœ‰ä¸¤ä¸ªå¾ˆç²¾å½©çš„å®ç°ï¼Œä¸€ä¸ªæ˜¯reloaderçš„æ³¨å†Œï¼Œä¸€ä¸ªæ˜¯ç»„ä»¶å¯åŠ¨ã€‚ä½†æ˜¯æœ‰ä¸ªé—®é¢˜ï¼Œæ‰€æœ‰çš„ç»„ä»¶éƒ½æ˜¯åŒæ—¶å¯åŠ¨çš„å—ï¼Ÿè¿˜æ˜¯æœ‰ä»€ä¹ˆé¡ºåºï¼Ÿ\næˆ‘ä»¬åˆ—ä¸€ä¸ªç»„ä»¶æ¸…å•ï¼š\n- Termination handler. - Scrape discovery manager. - Notify discovery manager. - Scrape manager. - Reload handler. - Rule manager. - TSDB. - Web handler. - Notifier. å†æ¥çœ‹ä¸€ä¸‹ç»„ä»¶å¯åŠ¨ä½¿ç”¨çš„åº•å±‚æŠ€æœ¯:\nrun.Group is a universal mechanism to manage goroutine lifecycles.\nCreate a zero-value run.Group, and then add actors to it. Actors are defined as a pair of functions: an execute function, which should run synchronously; and an interrupt function, which, when invoked, should cause the execute function to return. Finally, invoke Run, which concurrently runs all of the actors, waits until the first actor exits, invokes the interrupt functions, and finally returns control to the caller only once all actors have returned. This general-purpose API allows callers to model pretty much any runnable task, and achieve well-defined lifecycle semantics for the group.\n","keywords":["Golang","Prometheus","Observability"],"articleBody":" éçº¿æ€§ =\u003e çº¿æ€§ï¼Œæ··ä¹± =\u003e ç§©åº\nä¸Šä¸€ç¯‡åšæ–‡ä¸»è¦å†™äº†Prometheus serverçš„å¯åŠ¨è¿‡ç¨‹ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰æ·±å…¥å„ä¸ªç»„ä»¶ï¼Œäº†è§£å…¶å…·ä½“å®ç°ï¼Œè¿™ç¯‡æ–‡ä»¶ä¸»è¦ä»‹ç»Initial configuration loadingéƒ¨åˆ†ã€‚\nPrometheus serverçš„mainå‡½æ•°æœ‰ä¸¤ä¸ªå¾ˆç²¾å½©çš„å®ç°ï¼Œä¸€ä¸ªæ˜¯reloaderçš„æ³¨å†Œï¼Œä¸€ä¸ªæ˜¯ç»„ä»¶å¯åŠ¨ã€‚ä½†æ˜¯æœ‰ä¸ªé—®é¢˜ï¼Œæ‰€æœ‰çš„ç»„ä»¶éƒ½æ˜¯åŒæ—¶å¯åŠ¨çš„å—ï¼Ÿè¿˜æ˜¯æœ‰ä»€ä¹ˆé¡ºåºï¼Ÿ\næˆ‘ä»¬åˆ—ä¸€ä¸ªç»„ä»¶æ¸…å•ï¼š\n- Termination handler. - Scrape discovery manager. - Notify discovery manager. - Scrape manager. - Reload handler. - Rule manager. - TSDB. - Web handler. - Notifier. å†æ¥çœ‹ä¸€ä¸‹ç»„ä»¶å¯åŠ¨ä½¿ç”¨çš„åº•å±‚æŠ€æœ¯:\nrun.Group is a universal mechanism to manage goroutine lifecycles.\nCreate a zero-value run.Group, and then add actors to it. Actors are defined as a pair of functions: an execute function, which should run synchronously; and an interrupt function, which, when invoked, should cause the execute function to return. Finally, invoke Run, which concurrently runs all of the actors, waits until the first actor exits, invokes the interrupt functions, and finally returns control to the caller only once all actors have returned. This general-purpose API allows callers to model pretty much any runnable task, and achieve well-defined lifecycle semantics for the group.\nrun.Group was written to manage component lifecycles in func main for OK Log. But itâ€™s useful in any circumstance where you need to orchestrate multiple goroutines as a unit whole. Click here to see a video of a talk where run.Group is described.\nsource: https://pkg.go.dev/github.com/oklog/run\nç®€å•æ€»ç»“ä¸€ä¸‹ï¼Œoklog/runåº“çš„run.Groupå®ç°äº†ä¸€ç§goroutineç”Ÿå‘½çš„ç®¡ç†æœºåˆ¶ï¼Œä½¿ç”¨äº†actoræ¨¡å‹ï¼Œæ³¨å†Œä¸€å¯¹å‡½æ•°executeå’Œinterruptã€‚å›å¿†ä¸€ä¸‹ä¸Šç¯‡åšå®¢ï¼Œå®ç°æ­£æ˜¯å¦‚æ­¤ã€‚\nTermination handlerç»„ä»¶çš„executeå‡½æ•°ä½¿ç”¨selectç­‰å¾…termã€webHandlerã€cancelçš„é€šçŸ¥ï¼Œç”¨äºä¿è¯ç³»ç»Ÿæ­£å¸¸é€€å‡ºï¼Œè¿›å…¥å³é˜»å¡ã€‚\nScrape discovery managerç»„ä»¶ç›´æ¥è°ƒç”¨discoveryManagerScrape.Runã€‚\nNotify discovery managerç»„ä»¶ç›´æ¥è°ƒç”¨discoveryManagerNotify.Runã€‚\nScrape managerç»„ä»¶ç­‰å¾…reloadReady.Cé€šçŸ¥ï¼Œç„¶åè¿è¡ŒscrapeManager.Runã€‚\nReload handlerç»„ä»¶ç­‰å¾…reloadReady.Cé€šçŸ¥ï¼Œç„¶åç­‰å¾…hupã€webHandlerã€cancelçš„é€šçŸ¥ï¼Œæ ¹æ®é€šçŸ¥é‡æ–°åŠ è½½ã€‚\nInitial configuration loadingç»„ä»¶è¿›å…¥åç­‰å¾…dbOpenã€cancelé€šçŸ¥ï¼ŒdbOpené€šçŸ¥åï¼ŒåŠ è½½é…ç½®ã€‚\nRule managerç»„ä»¶ç­‰å¾…reloadReady.Cé€šçŸ¥ï¼Œç„¶åè¿è¡ŒruleManager.Runã€‚\nTSDBç»„ä»¶è¿è¡ŒopenDBWithMetricsï¼Œç„¶åclose dbOpen channelã€‚\nWeb handlerç»„ä»¶ç›´æ¥è°ƒç”¨webHandler.Runã€‚\nNotifierç»„ä»¶ç­‰å¾…reloadReady.Cé€šçŸ¥ï¼Œç„¶åè°ƒç”¨notifierManager.Runã€‚\nå¯ä»¥çœ‹å‡ºæ•´ä¸ªæ§åˆ¶æµç¨‹æœ‰ä¸¤ä¸ªå¾ˆé‡è¦çš„channelï¼šdbOpenå’ŒreloadReady.Cã€‚æˆ‘ä»¬å†çœ‹çœ‹è¿™ä¸¤ä¸ªchannelï¼Œ\n// Start all components while we wait for TSDB to open but only load // initial config and mark ourselves as ready after it completed. dbOpen := make(chan struct{}) // sync.Once is used to make sure we can close the channel at different execution stages(SIGTERM or when the config is loaded). type closeOnce struct { C chan struct{} once sync.Once Close func() } // Wait until the server is ready to handle reloading. reloadReady := \u0026closeOnce{ C: make(chan struct{}), } reloadReady.Close = func() { reloadReady.once.Do(func() { close(reloadReady.C) }) } æ ¹æ®ä¸Šé¢çš„æ€»ç»“ï¼ŒTermination handlerã€Scrape discovery managerã€Notify discovery managerã€TSDBã€Web handlerç»„ä»¶ç›´æ¥è¿è¡Œï¼ŒTSDBåˆå§‹åŒ–ç»“æŸåï¼Œå…³é—­dbOpen channelï¼Œæ¥ç€Initial configuration loadingç»“æŸé˜»å¡ï¼Œå¼€å§‹è¿è¡Œï¼Œåœ¨æŸå¤„å…³é—­äº†reloadReady.C channelåï¼Œç­‰å¾…è¯¥channelé€šçŸ¥çš„ç»„ä»¶å¼€å§‹è¿è¡Œã€‚\nInitial configuration loadingç»„ä»¶çš„executeå‡½æ•°å¦‚ä¸‹ï¼Œå¯è§æœ€é‡è¦çš„å°±æ˜¯reloadConfigå‡½æ•°çš„å®ç°\nselect { case \u003c-dbOpen: // In case a shutdown is initiated before the dbOpen is released case \u003c-cancel: reloadReady.Close() return nil } if err := reloadConfig(cfg.configFile, logger, noStepSubqueryInterval, reloaders...); err != nil { return errors.Wrapf(err, \"error loading config from %q\", cfg.configFile) } reloadReady.Close() reloadConfigå‡½æ•°å®ç°å¦‚ä¸‹\nfunc reloadConfig(filename string, logger log.Logger, noStepSuqueryInterval *safePromQLNoStepSubqueryInterval, rls ...reloader) (err error) { start := time.Now() timings := []interface{}{} level.Info(logger).Log(\"msg\", \"Loading configuration file\", \"filename\", filename) defer func() { if err == nil { configSuccess.Set(1) configSuccessTime.SetToCurrentTime() } else { configSuccess.Set(0) } }() conf, err := config.LoadFile(filename) if err != nil { return errors.Wrapf(err, \"couldn't load configuration (--config.file=%q)\", filename) } failed := false for _, rl := range rls { rstart := time.Now() if err := rl.reloader(conf); err != nil { level.Error(logger).Log(\"msg\", \"Failed to apply configuration\", \"err\", err) failed = true } timings = append(timings, rl.name, time.Since(rstart)) } if failed { return errors.Errorf(\"one or more errors occurred while applying the new configuration (--config.file=%q)\", filename) } noStepSuqueryInterval.Set(conf.GlobalConfig.EvaluationInterval) l := []interface{}{\"msg\", \"Completed loading of configuration file\", \"filename\", filename, \"totalDuration\", time.Since(start)} level.Info(logger).Log(append(l, timings...)...) return nil } è¯¥å‡½æ•°é‡Œé¢æœ‰ä¸¤ä¸ªé‡è¦åŠŸèƒ½ï¼Œä¸€ä¸ªæ˜¯è§£æé…ç½®æ–‡ä»¶ï¼Œå¦ä¸€ä¸ªæ˜¯è°ƒç”¨reloaderã€‚reloaderçš„è°ƒç”¨å…ˆä¸æ·±ç©¶ï¼Œæˆ‘ä»¬ç•™åˆ°ä¸‹ä¸€ç¯‡è®²scrapeçš„æ—¶å€™å†ç ”ç©¶ï¼Œè¿™é‡Œå…ˆç ”ç©¶ä¸€ä¸‹é…ç½®æ–‡ä»¶çš„è§£æï¼Œè¿™ä¸ªä¹Ÿæ˜¯ç›¸å½“ç²¾å½©çš„ã€‚é…ç½®æ–‡ä»¶çš„structå®šä¹‰å¦‚ä¸‹ï¼Œ\ntype Config struct { GlobalConfig GlobalConfig `yaml:\"global\"` AlertingConfig AlertingConfig `yaml:\"alerting,omitempty\"` RuleFiles []string `yaml:\"rule_files,omitempty\"` ScrapeConfigs []*ScrapeConfig `yaml:\"scrape_configs,omitempty\"` RemoteWriteConfigs []*RemoteWriteConfig `yaml:\"remote_write,omitempty\"` RemoteReadConfigs []*RemoteReadConfig `yaml:\"remote_read,omitempty\"` } å› ä¸ºéœ€è¦æ”¯æŒå„ç§åŠ¨æ€å‘ç°ç»„ä»¶ï¼ŒServiceDiscoveryConfigsåœ¨è¿™é‡Œtag keyä¸ºâ€œ-â€ï¼Œè¡¨ç¤ºä¸è§£æï¼Œconfig.goè‡ªå®šä¹‰å®ç°äº†UnmarshalYAMLï¼Œç”¨äºè§£æé…ç½®\ntype ScrapeConfig struct { // The job name to which the job label is set by default. JobName string `yaml:\"job_name\"` // Indicator whether the scraped metrics should remain unmodified. HonorLabels bool `yaml:\"honor_labels,omitempty\"` // Indicator whether the scraped timestamps should be respected. HonorTimestamps bool `yaml:\"honor_timestamps\"` // A set of query parameters with which the target is scraped. Params url.Values `yaml:\"params,omitempty\"` // How frequently to scrape the targets of this scrape config. ScrapeInterval model.Duration `yaml:\"scrape_interval,omitempty\"` // The timeout for scraping targets of this config. ScrapeTimeout model.Duration `yaml:\"scrape_timeout,omitempty\"` // The HTTP resource path on which to fetch metrics from targets. MetricsPath string `yaml:\"metrics_path,omitempty\"` // The URL scheme with which to fetch metrics from targets. Scheme string `yaml:\"scheme,omitempty\"` // More than this many samples post metric-relabeling will cause the scrape to fail. SampleLimit uint `yaml:\"sample_limit,omitempty\"` // More than this many targets after the target relabeling will cause the // scrapes to fail. TargetLimit uint `yaml:\"target_limit,omitempty\"` // We cannot do proper Go type embedding below as the parser will then parse // values arbitrarily into the overflow maps of further-down types. ServiceDiscoveryConfigs discovery.Configs `yaml:\"-\"` HTTPClientConfig config.HTTPClientConfig `yaml:\",inline\"` // List of target relabel configurations. RelabelConfigs []*relabel.Config `yaml:\"relabel_configs,omitempty\"` // List of metric relabel configurations. MetricRelabelConfigs []*relabel.Config `yaml:\"metric_relabel_configs,omitempty\"` } conf, err := config.LoadFile(filename)è¿™ä¸ªè°ƒç”¨è¿”å›ä¸€ä¸ªConfigæŒ‡é’ˆï¼Œ\nfunc Load(s string) (*Config, error) { cfg := \u0026Config{} // If the entire config body is empty the UnmarshalYAML method is // never called. We thus have to set the DefaultConfig at the entry // point as well. *cfg = DefaultConfig err := yaml.UnmarshalStrict([]byte(s), cfg) if err != nil { return nil, err } return cfg, nil } err := yaml.UnmarshalStrict([]byte(s), cfg)è°ƒç”¨Configçš„yaml Unmarshalæ–¹æ³•ï¼Œè§£æé…ç½®ï¼Œä½†æ˜¯Prometheusè‡ªå®šä¹‰äº†æ•´ä¸ªé…ç½®æ–‡ä»¶çš„è§£æï¼ŒConfigçš„UnmarshalYAMLå®ç°å¦‚ä¸‹ï¼š\nfunc (c *Config) UnmarshalYAML(unmarshal func(interface{}) error) error { *c = DefaultConfig // We want to set c to the defaults and then overwrite it with the input. // To make unmarshal fill the plain data struct rather than calling UnmarshalYAML // again, we have to hide it using a type indirection. type plain Config if err := unmarshal((*plain)(c)); err != nil { return err } // If a global block was open but empty the default global config is overwritten. // We have to restore it here. if c.GlobalConfig.isZero() { c.GlobalConfig = DefaultGlobalConfig } for _, rf := range c.RuleFiles { if !patRulePath.MatchString(rf) { return errors.Errorf(\"invalid rule file path %q\", rf) } } // Do global overrides and validate unique names. jobNames := map[string]struct{}{} for _, scfg := range c.ScrapeConfigs { if scfg == nil { return errors.New(\"empty or null scrape config section\") } // First set the correct scrape interval, then check that the timeout // (inferred or explicit) is not greater than that. if scfg.ScrapeInterval == 0 { scfg.ScrapeInterval = c.GlobalConfig.ScrapeInterval } if scfg.ScrapeTimeout \u003e scfg.ScrapeInterval { return errors.Errorf(\"scrape timeout greater than scrape interval for scrape config with job name %q\", scfg.JobName) } if scfg.ScrapeTimeout == 0 { if c.GlobalConfig.ScrapeTimeout \u003e scfg.ScrapeInterval { scfg.ScrapeTimeout = scfg.ScrapeInterval } else { scfg.ScrapeTimeout = c.GlobalConfig.ScrapeTimeout } } if _, ok := jobNames[scfg.JobName]; ok { return errors.Errorf(\"found multiple scrape configs with job name %q\", scfg.JobName) } jobNames[scfg.JobName] = struct{}{} } rwNames := map[string]struct{}{} for _, rwcfg := range c.RemoteWriteConfigs { if rwcfg == nil { return errors.New(\"empty or null remote write config section\") } // Skip empty names, we fill their name with their config hash in remote write code. if _, ok := rwNames[rwcfg.Name]; ok \u0026\u0026 rwcfg.Name != \"\" { return errors.Errorf(\"found multiple remote write configs with job name %q\", rwcfg.Name) } rwNames[rwcfg.Name] = struct{}{} } rrNames := map[string]struct{}{} for _, rrcfg := range c.RemoteReadConfigs { if rrcfg == nil { return errors.New(\"empty or null remote read config section\") } // Skip empty names, we fill their name with their config hash in remote read code. if _, ok := rrNames[rrcfg.Name]; ok \u0026\u0026 rrcfg.Name != \"\" { return errors.Errorf(\"found multiple remote read configs with job name %q\", rrcfg.Name) } rrNames[rrcfg.Name] = struct{}{} } return nil } è¿™ä¸ªé…ç½®çš„è§£æå’ŒéªŒè¯å®åœ¨æ˜¯å¤ªå¤æ‚äº†ï¼Œæˆ‘ä»¬ä¸ç®¡å…¶ä»–struct fieldçš„unmarshalï¼Œå…³æ³¨scrape configsçš„è§£æï¼Œ\nfunc (c *ScrapeConfig) UnmarshalYAML(unmarshal func(interface{}) error) error { *c = DefaultScrapeConfig if err := discovery.UnmarshalYAMLWithInlineConfigs(c, unmarshal); err != nil { return err } if len(c.JobName) == 0 { return errors.New(\"job_name is empty\") } // The UnmarshalYAML method of HTTPClientConfig is not being called because it's not a pointer. // We cannot make it a pointer as the parser panics for inlined pointer structs. // Thus we just do its validation here. if err := c.HTTPClientConfig.Validate(); err != nil { return err } // Check for users putting URLs in target groups. if len(c.RelabelConfigs) == 0 { if err := checkStaticTargets(c.ServiceDiscoveryConfigs); err != nil { return err } } for _, rlcfg := range c.RelabelConfigs { if rlcfg == nil { return errors.New(\"empty or null target relabeling rule in scrape config\") } } for _, rlcfg := range c.MetricRelabelConfigs { if rlcfg == nil { return errors.New(\"empty or null metric relabeling rule in scrape config\") } } return nil } err := discovery.UnmarshalYAMLWithInlineConfigs(c, unmarshal)é‡Œé¢æ˜¯è§£æåŠ¨æ€å‘ç°çš„å…·ä½“å®ç°ï¼Œ let us drill downï¼š\nfunc UnmarshalYAMLWithInlineConfigs(out interface{}, unmarshal func(interface{}) error) error { outVal := reflect.ValueOf(out) if outVal.Kind() != reflect.Ptr { return fmt.Errorf(\"discovery: can only unmarshal into a struct pointer: %T\", out) } outVal = outVal.Elem() if outVal.Kind() != reflect.Struct { return fmt.Errorf(\"discovery: can only unmarshal into a struct pointer: %T\", out) } outTyp := outVal.Type() cfgTyp := getConfigType(outTyp) cfgPtr := reflect.New(cfgTyp) cfgVal := cfgPtr.Elem() // Copy shared fields (defaults) to dynamic value. var configs *Configs for i, n := 0, outVal.NumField(); i \u003c n; i++ { if outTyp.Field(i).Type == configsType { configs = outVal.Field(i).Addr().Interface().(*Configs) continue } if cfgTyp.Field(i).PkgPath != \"\" { continue // Field is unexported: ignore. } cfgVal.Field(i).Set(outVal.Field(i)) } if configs == nil { return fmt.Errorf(\"discovery: Configs field not found in type: %T\", out) } // Unmarshal into dynamic value. if err := unmarshal(cfgPtr.Interface()); err != nil { return replaceYAMLTypeError(err, cfgTyp, outTyp) } // Copy shared fields from dynamic value. for i, n := 0, outVal.NumField(); i \u003c n; i++ { if cfgTyp.Field(i).PkgPath != \"\" { continue // Field is unexported: ignore. } outVal.Field(i).Set(cfgVal.Field(i)) } var err error *configs, err = readConfigs(cfgVal, outVal.NumField()) return err } Oh, my god! è¿™ä¸ªå¤ªåˆºæ¿€äº†ï¼Œç”¨reflectå»å®ç°åº•å±‚çš„æ•°æ®è§£æï¼Œè¿™ä¸ªä»¥åè¦çœ‹çœ‹åº•å±‚çš„å®ç°ï¼Œå…ˆä¸ç®¡äº†ï¼Œæˆ‘ä»¬çœ‹åˆ°ä¸Šé¢å‡½æ•°çš„å€’æ•°ç¬¬äºŒå¥æœ‰è¿™æ ·ä¸€ä¸ªè°ƒç”¨*configs, err = readConfigs(cfgVal, outVal.NumField())ï¼Œç»§ç»­drill down\nfunc readConfigs(structVal reflect.Value, startField int) (Configs, error) { var ( configs Configs targets []*targetgroup.Group ) for i, n := startField, structVal.NumField(); i \u003c n; i++ { field := structVal.Field(i) if field.Kind() != reflect.Slice { panic(\"discovery: internal error: field is not a slice\") } for k := 0; k \u003c field.Len(); k++ { val := field.Index(k) if val.IsZero() || (val.Kind() == reflect.Ptr \u0026\u0026 val.Elem().IsZero()) { key := configFieldNames[field.Type().Elem()] key = strings.TrimPrefix(key, configFieldPrefix) return nil, fmt.Errorf(\"empty or null section in %s\", key) } switch c := val.Interface().(type) { case *targetgroup.Group: // Add index to the static config target groups for unique identification // within scrape pool. c.Source = strconv.Itoa(len(targets)) // Coalesce multiple static configs into a single static config. targets = append(targets, c) case Config: configs = append(configs, c) default: panic(\"discovery: internal error: slice element is not a Config\") } } } if len(targets) \u003e 0 { configs = append(configs, StaticConfig(targets)) } return configs, nil } å‰å®³äº†å‰å®³äº†ï¼Œæˆ‘ä»¬ç»ˆäºè§£æå®Œäº†scrape configï¼Œç»ˆäºçŸ¥é“å¯ä»¥å»æŠ“å–å“ªäº›ç›®æ ‡metricsäº†ã€‚å—¯ï¼Œåˆæœ‰æ–°ç›®æ ‡ï¼Œäº†è§£yamlåº•å±‚è§£æçš„åŸç†ï¼ï¼ï¼\nä¸‹ä¸€ç¯‡æˆ‘ä»¬æ¥ç€ç ”ç©¶Prometheus serverçš„scrapeå®ç°ã€‚\n","wordCount":"1677","inLanguage":"en","image":"https://solaim.github.io/img/favicon.webp","datePublished":"2021-03-20T21:29:33+08:00","dateModified":"2021-03-20T21:29:33+08:00","author":{"@type":"Person","name":"Jerry Wang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://solaim.github.io/posts/prometheus%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E4%B8%89/"},"publisher":{"@type":"Organization","name":"Jerry Wang","logo":{"@type":"ImageObject","url":"https://solaim.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://solaim.github.io/ accesskey=h title="é¦–é¡µ (Alt + H)"><img src=https://solaim.github.io/apple-touch-icon.png alt aria-label=logo height=35>é¦–é¡µ</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://solaim.github.io/categories/ title=ğŸ•¸åˆ†ç±»><span>ğŸ•¸åˆ†ç±»</span></a></li><li><a href=https://solaim.github.io/tags/ title=ğŸšæ ‡ç­¾><span>ğŸšæ ‡ç­¾</span></a></li><li><a href=https://solaim.github.io/about/ title=ğŸŒå…³äº><span>ğŸŒå…³äº</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://solaim.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://solaim.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Prometheuså†…éƒ¨å®ç°(ä¸‰)</h1><div class=post-meta><span title='2021-03-20 21:29:33 +0800 +0800'>2021-03-20</span>&nbsp;Â·&nbsp;Jerry Wang</div></header><div class=post-content><blockquote><p>éçº¿æ€§ => çº¿æ€§ï¼Œæ··ä¹± => ç§©åº</p></blockquote><p>ä¸Šä¸€ç¯‡åšæ–‡ä¸»è¦å†™äº†Prometheus serverçš„å¯åŠ¨è¿‡ç¨‹ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰æ·±å…¥å„ä¸ªç»„ä»¶ï¼Œäº†è§£å…¶å…·ä½“å®ç°ï¼Œè¿™ç¯‡æ–‡ä»¶ä¸»è¦ä»‹ç»Initial configuration loadingéƒ¨åˆ†ã€‚</p><p>Prometheus serverçš„mainå‡½æ•°æœ‰ä¸¤ä¸ªå¾ˆç²¾å½©çš„å®ç°ï¼Œä¸€ä¸ªæ˜¯reloaderçš„æ³¨å†Œï¼Œä¸€ä¸ªæ˜¯ç»„ä»¶å¯åŠ¨ã€‚ä½†æ˜¯æœ‰ä¸ªé—®é¢˜ï¼Œæ‰€æœ‰çš„ç»„ä»¶éƒ½æ˜¯åŒæ—¶å¯åŠ¨çš„å—ï¼Ÿè¿˜æ˜¯æœ‰ä»€ä¹ˆé¡ºåºï¼Ÿ</p><p>æˆ‘ä»¬åˆ—ä¸€ä¸ªç»„ä»¶æ¸…å•ï¼š</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>- Termination handler.
</span></span><span class=line><span class=cl>- Scrape discovery manager.
</span></span><span class=line><span class=cl>- Notify discovery manager.
</span></span><span class=line><span class=cl>- Scrape manager.
</span></span><span class=line><span class=cl>- Reload handler.
</span></span><span class=line><span class=cl>- Rule manager.
</span></span><span class=line><span class=cl>- TSDB.
</span></span><span class=line><span class=cl>- Web handler.
</span></span><span class=line><span class=cl>- Notifier.
</span></span></code></pre></div><p>å†æ¥çœ‹ä¸€ä¸‹ç»„ä»¶å¯åŠ¨ä½¿ç”¨çš„åº•å±‚æŠ€æœ¯:</p><blockquote><p>run.Group is a universal mechanism to manage goroutine lifecycles.</p><p>Create a zero-value run.Group, and then add actors to it. Actors are defined as a pair of functions: an <strong>execute</strong> function, which should run synchronously; and an <strong>interrupt</strong> function, which, when invoked, should cause the execute function to return. Finally, invoke Run, which concurrently runs all of the actors, waits until the first actor exits, invokes the interrupt functions, and finally returns control to the caller only once all actors have returned. This general-purpose API allows callers to model pretty much any runnable task, and achieve well-defined lifecycle semantics for the group.</p><p>run.Group was written to manage component lifecycles in func main for <a href=https://github.com/oklog/oklog>OK Log</a>. But it&rsquo;s useful in any circumstance where you need to orchestrate multiple goroutines as a unit whole. <a href="https://www.youtube.com/watch?v=LHe1Cb_Ud_M&amp;t=15m45s">Click here</a> to see a video of a talk where run.Group is described.</p><p>source: <a href=https://pkg.go.dev/github.com/oklog/run>https://pkg.go.dev/github.com/oklog/run</a></p></blockquote><p>ç®€å•æ€»ç»“ä¸€ä¸‹ï¼Œoklog/runåº“çš„run.Groupå®ç°äº†ä¸€ç§goroutineç”Ÿå‘½çš„ç®¡ç†æœºåˆ¶ï¼Œä½¿ç”¨äº†actoræ¨¡å‹ï¼Œæ³¨å†Œä¸€å¯¹å‡½æ•°executeå’Œinterruptã€‚å›å¿†ä¸€ä¸‹ä¸Šç¯‡åšå®¢ï¼Œå®ç°æ­£æ˜¯å¦‚æ­¤ã€‚</p><p>Termination handlerç»„ä»¶çš„executeå‡½æ•°ä½¿ç”¨selectç­‰å¾…termã€webHandlerã€cancelçš„é€šçŸ¥ï¼Œç”¨äºä¿è¯ç³»ç»Ÿæ­£å¸¸é€€å‡ºï¼Œè¿›å…¥å³é˜»å¡ã€‚</p><p>Scrape discovery managerç»„ä»¶ç›´æ¥è°ƒç”¨discoveryManagerScrape.Runã€‚</p><p>Notify discovery managerç»„ä»¶ç›´æ¥è°ƒç”¨discoveryManagerNotify.Runã€‚</p><p>Scrape managerç»„ä»¶ç­‰å¾…reloadReady.Cé€šçŸ¥ï¼Œç„¶åè¿è¡ŒscrapeManager.Runã€‚</p><p>Reload handlerç»„ä»¶ç­‰å¾…reloadReady.Cé€šçŸ¥ï¼Œç„¶åç­‰å¾…hupã€webHandlerã€cancelçš„é€šçŸ¥ï¼Œæ ¹æ®é€šçŸ¥é‡æ–°åŠ è½½ã€‚</p><p>Initial configuration loadingç»„ä»¶è¿›å…¥åç­‰å¾…dbOpenã€cancelé€šçŸ¥ï¼ŒdbOpené€šçŸ¥åï¼ŒåŠ è½½é…ç½®ã€‚</p><p>Rule managerç»„ä»¶ç­‰å¾…reloadReady.Cé€šçŸ¥ï¼Œç„¶åè¿è¡ŒruleManager.Runã€‚</p><p>TSDBç»„ä»¶è¿è¡ŒopenDBWithMetricsï¼Œç„¶åclose dbOpen channelã€‚</p><p>Web handlerç»„ä»¶ç›´æ¥è°ƒç”¨webHandler.Runã€‚</p><p>Notifierç»„ä»¶ç­‰å¾…reloadReady.Cé€šçŸ¥ï¼Œç„¶åè°ƒç”¨notifierManager.Runã€‚</p><p>å¯ä»¥çœ‹å‡ºæ•´ä¸ªæ§åˆ¶æµç¨‹æœ‰ä¸¤ä¸ªå¾ˆé‡è¦çš„channelï¼šdbOpenå’ŒreloadReady.Cã€‚æˆ‘ä»¬å†çœ‹çœ‹è¿™ä¸¤ä¸ªchannelï¼Œ</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Start all components while we wait for TSDB to open but only load</span>
</span></span><span class=line><span class=cl><span class=c1>// initial config and mark ourselves as ready after it completed.</span>
</span></span><span class=line><span class=cl><span class=nx>dbOpen</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// sync.Once is used to make sure we can close the channel at different execution stages(SIGTERM or when the config is loaded).</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>closeOnce</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>C</span>     <span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=nx>once</span>  <span class=nx>sync</span><span class=p>.</span><span class=nx>Once</span>
</span></span><span class=line><span class=cl>  <span class=nx>Close</span> <span class=kd>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// Wait until the server is ready to handle reloading.</span>
</span></span><span class=line><span class=cl><span class=nx>reloadReady</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>closeOnce</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>C</span><span class=p>:</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}),</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>reloadReady</span><span class=p>.</span><span class=nx>Close</span> <span class=p>=</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>reloadReady</span><span class=p>.</span><span class=nx>once</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>close</span><span class=p>(</span><span class=nx>reloadReady</span><span class=p>.</span><span class=nx>C</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>æ ¹æ®ä¸Šé¢çš„æ€»ç»“ï¼ŒTermination handlerã€Scrape discovery managerã€Notify discovery managerã€TSDBã€Web handlerç»„ä»¶ç›´æ¥è¿è¡Œï¼ŒTSDBåˆå§‹åŒ–ç»“æŸåï¼Œå…³é—­dbOpen channelï¼Œæ¥ç€Initial configuration loadingç»“æŸé˜»å¡ï¼Œå¼€å§‹è¿è¡Œï¼Œåœ¨æŸå¤„å…³é—­äº†reloadReady.C channelåï¼Œç­‰å¾…è¯¥channelé€šçŸ¥çš„ç»„ä»¶å¼€å§‹è¿è¡Œã€‚</p><p>Initial configuration loadingç»„ä»¶çš„executeå‡½æ•°å¦‚ä¸‹ï¼Œå¯è§æœ€é‡è¦çš„å°±æ˜¯reloadConfigå‡½æ•°çš„å®ç°</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>dbOpen</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>// In case a shutdown is initiated before the dbOpen is released</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>cancel</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=nx>reloadReady</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>reloadConfig</span><span class=p>(</span><span class=nx>cfg</span><span class=p>.</span><span class=nx>configFile</span><span class=p>,</span> <span class=nx>logger</span><span class=p>,</span> <span class=nx>noStepSubqueryInterval</span><span class=p>,</span> <span class=nx>reloaders</span><span class=o>...</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Wrapf</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=s>&#34;error loading config from %q&#34;</span><span class=p>,</span> <span class=nx>cfg</span><span class=p>.</span><span class=nx>configFile</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>reloadReady</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span></code></pre></div><p>reloadConfigå‡½æ•°å®ç°å¦‚ä¸‹</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>reloadConfig</span><span class=p>(</span><span class=nx>filename</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>logger</span> <span class=nx>log</span><span class=p>.</span><span class=nx>Logger</span><span class=p>,</span> <span class=nx>noStepSuqueryInterval</span> <span class=o>*</span><span class=nx>safePromQLNoStepSubqueryInterval</span><span class=p>,</span> <span class=nx>rls</span> <span class=o>...</span><span class=nx>reloader</span><span class=p>)</span> <span class=p>(</span><span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>start</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=nx>timings</span> <span class=o>:=</span> <span class=p>[]</span><span class=kd>interface</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>  <span class=nx>level</span><span class=p>.</span><span class=nf>Info</span><span class=p>(</span><span class=nx>logger</span><span class=p>).</span><span class=nf>Log</span><span class=p>(</span><span class=s>&#34;msg&#34;</span><span class=p>,</span> <span class=s>&#34;Loading configuration file&#34;</span><span class=p>,</span> <span class=s>&#34;filename&#34;</span><span class=p>,</span> <span class=nx>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>configSuccess</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nx>configSuccessTime</span><span class=p>.</span><span class=nf>SetToCurrentTime</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>configSuccess</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>conf</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>config</span><span class=p>.</span><span class=nf>LoadFile</span><span class=p>(</span><span class=nx>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Wrapf</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=s>&#34;couldn&#39;t load configuration (--config.file=%q)&#34;</span><span class=p>,</span> <span class=nx>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>failed</span> <span class=o>:=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>rl</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>rls</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>rstart</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rl</span><span class=p>.</span><span class=nf>reloader</span><span class=p>(</span><span class=nx>conf</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>level</span><span class=p>.</span><span class=nf>Error</span><span class=p>(</span><span class=nx>logger</span><span class=p>).</span><span class=nf>Log</span><span class=p>(</span><span class=s>&#34;msg&#34;</span><span class=p>,</span> <span class=s>&#34;Failed to apply configuration&#34;</span><span class=p>,</span> <span class=s>&#34;err&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nx>failed</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>timings</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>timings</span><span class=p>,</span> <span class=nx>rl</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Since</span><span class=p>(</span><span class=nx>rstart</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>failed</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;one or more errors occurred while applying the new configuration (--config.file=%q)&#34;</span><span class=p>,</span> <span class=nx>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>noStepSuqueryInterval</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=nx>conf</span><span class=p>.</span><span class=nx>GlobalConfig</span><span class=p>.</span><span class=nx>EvaluationInterval</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>l</span> <span class=o>:=</span> <span class=p>[]</span><span class=kd>interface</span><span class=p>{}{</span><span class=s>&#34;msg&#34;</span><span class=p>,</span> <span class=s>&#34;Completed loading of configuration file&#34;</span><span class=p>,</span> <span class=s>&#34;filename&#34;</span><span class=p>,</span> <span class=nx>filename</span><span class=p>,</span> <span class=s>&#34;totalDuration&#34;</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Since</span><span class=p>(</span><span class=nx>start</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>  <span class=nx>level</span><span class=p>.</span><span class=nf>Info</span><span class=p>(</span><span class=nx>logger</span><span class=p>).</span><span class=nf>Log</span><span class=p>(</span><span class=nb>append</span><span class=p>(</span><span class=nx>l</span><span class=p>,</span> <span class=nx>timings</span><span class=o>...</span><span class=p>)</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>è¯¥å‡½æ•°é‡Œé¢æœ‰ä¸¤ä¸ªé‡è¦åŠŸèƒ½ï¼Œä¸€ä¸ªæ˜¯è§£æé…ç½®æ–‡ä»¶ï¼Œå¦ä¸€ä¸ªæ˜¯è°ƒç”¨reloaderã€‚reloaderçš„è°ƒç”¨å…ˆä¸æ·±ç©¶ï¼Œæˆ‘ä»¬ç•™åˆ°ä¸‹ä¸€ç¯‡è®²scrapeçš„æ—¶å€™å†ç ”ç©¶ï¼Œè¿™é‡Œå…ˆç ”ç©¶ä¸€ä¸‹é…ç½®æ–‡ä»¶çš„è§£æï¼Œè¿™ä¸ªä¹Ÿæ˜¯ç›¸å½“ç²¾å½©çš„ã€‚é…ç½®æ–‡ä»¶çš„structå®šä¹‰å¦‚ä¸‹ï¼Œ</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Config</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>GlobalConfig</span>   <span class=nx>GlobalConfig</span>    <span class=s>`yaml:&#34;global&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=nx>AlertingConfig</span> <span class=nx>AlertingConfig</span>  <span class=s>`yaml:&#34;alerting,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=nx>RuleFiles</span>      <span class=p>[]</span><span class=kt>string</span>        <span class=s>`yaml:&#34;rule_files,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=nx>ScrapeConfigs</span>  <span class=p>[]</span><span class=o>*</span><span class=nx>ScrapeConfig</span> <span class=s>`yaml:&#34;scrape_configs,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>RemoteWriteConfigs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>RemoteWriteConfig</span> <span class=s>`yaml:&#34;remote_write,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=nx>RemoteReadConfigs</span>  <span class=p>[]</span><span class=o>*</span><span class=nx>RemoteReadConfig</span>  <span class=s>`yaml:&#34;remote_read,omitempty&#34;`</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>å› ä¸ºéœ€è¦æ”¯æŒå„ç§åŠ¨æ€å‘ç°ç»„ä»¶ï¼ŒServiceDiscoveryConfigsåœ¨è¿™é‡Œtag keyä¸ºâ€œ-â€ï¼Œè¡¨ç¤ºä¸è§£æï¼Œconfig.goè‡ªå®šä¹‰å®ç°äº†UnmarshalYAMLï¼Œç”¨äºè§£æé…ç½®</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ScrapeConfig</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// The job name to which the job label is set by default.</span>
</span></span><span class=line><span class=cl>	<span class=nx>JobName</span> <span class=kt>string</span> <span class=s>`yaml:&#34;job_name&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Indicator whether the scraped metrics should remain unmodified.</span>
</span></span><span class=line><span class=cl>	<span class=nx>HonorLabels</span> <span class=kt>bool</span> <span class=s>`yaml:&#34;honor_labels,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Indicator whether the scraped timestamps should be respected.</span>
</span></span><span class=line><span class=cl>	<span class=nx>HonorTimestamps</span> <span class=kt>bool</span> <span class=s>`yaml:&#34;honor_timestamps&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=c1>// A set of query parameters with which the target is scraped.</span>
</span></span><span class=line><span class=cl>	<span class=nx>Params</span> <span class=nx>url</span><span class=p>.</span><span class=nx>Values</span> <span class=s>`yaml:&#34;params,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=c1>// How frequently to scrape the targets of this scrape config.</span>
</span></span><span class=line><span class=cl>	<span class=nx>ScrapeInterval</span> <span class=nx>model</span><span class=p>.</span><span class=nx>Duration</span> <span class=s>`yaml:&#34;scrape_interval,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=c1>// The timeout for scraping targets of this config.</span>
</span></span><span class=line><span class=cl>	<span class=nx>ScrapeTimeout</span> <span class=nx>model</span><span class=p>.</span><span class=nx>Duration</span> <span class=s>`yaml:&#34;scrape_timeout,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=c1>// The HTTP resource path on which to fetch metrics from targets.</span>
</span></span><span class=line><span class=cl>	<span class=nx>MetricsPath</span> <span class=kt>string</span> <span class=s>`yaml:&#34;metrics_path,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=c1>// The URL scheme with which to fetch metrics from targets.</span>
</span></span><span class=line><span class=cl>	<span class=nx>Scheme</span> <span class=kt>string</span> <span class=s>`yaml:&#34;scheme,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=c1>// More than this many samples post metric-relabeling will cause the scrape to fail.</span>
</span></span><span class=line><span class=cl>	<span class=nx>SampleLimit</span> <span class=kt>uint</span> <span class=s>`yaml:&#34;sample_limit,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=c1>// More than this many targets after the target relabeling will cause the</span>
</span></span><span class=line><span class=cl>	<span class=c1>// scrapes to fail.</span>
</span></span><span class=line><span class=cl>	<span class=nx>TargetLimit</span> <span class=kt>uint</span> <span class=s>`yaml:&#34;target_limit,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// We cannot do proper Go type embedding below as the parser will then parse</span>
</span></span><span class=line><span class=cl>	<span class=c1>// values arbitrarily into the overflow maps of further-down types.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>ServiceDiscoveryConfigs</span> <span class=nx>discovery</span><span class=p>.</span><span class=nx>Configs</span>       <span class=s>`yaml:&#34;-&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=nx>HTTPClientConfig</span>        <span class=nx>config</span><span class=p>.</span><span class=nx>HTTPClientConfig</span> <span class=s>`yaml:&#34;,inline&#34;`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// List of target relabel configurations.</span>
</span></span><span class=line><span class=cl>	<span class=nx>RelabelConfigs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>relabel</span><span class=p>.</span><span class=nx>Config</span> <span class=s>`yaml:&#34;relabel_configs,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=c1>// List of metric relabel configurations.</span>
</span></span><span class=line><span class=cl>	<span class=nx>MetricRelabelConfigs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>relabel</span><span class=p>.</span><span class=nx>Config</span> <span class=s>`yaml:&#34;metric_relabel_configs,omitempty&#34;`</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>conf, err := config.LoadFile(filename)</code>è¿™ä¸ªè°ƒç”¨è¿”å›ä¸€ä¸ªConfigæŒ‡é’ˆï¼Œ</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Load</span><span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>Config</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>cfg</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Config</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// If the entire config body is empty the UnmarshalYAML method is</span>
</span></span><span class=line><span class=cl>  <span class=c1>// never called. We thus have to set the DefaultConfig at the entry</span>
</span></span><span class=line><span class=cl>  <span class=c1>// point as well.</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=nx>cfg</span> <span class=p>=</span> <span class=nx>DefaultConfig</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>err</span> <span class=o>:=</span> <span class=nx>yaml</span><span class=p>.</span><span class=nf>UnmarshalStrict</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>s</span><span class=p>),</span> <span class=nx>cfg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>cfg</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>err := yaml.UnmarshalStrict([]byte(s), cfg)</code>è°ƒç”¨Configçš„yaml Unmarshalæ–¹æ³•ï¼Œè§£æé…ç½®ï¼Œä½†æ˜¯Prometheusè‡ªå®šä¹‰äº†æ•´ä¸ªé…ç½®æ–‡ä»¶çš„è§£æï¼ŒConfigçš„UnmarshalYAMLå®ç°å¦‚ä¸‹ï¼š</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>Config</span><span class=p>)</span> <span class=nf>UnmarshalYAML</span><span class=p>(</span><span class=nx>unmarshal</span> <span class=kd>func</span><span class=p>(</span><span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=nx>c</span> <span class=p>=</span> <span class=nx>DefaultConfig</span>
</span></span><span class=line><span class=cl>  <span class=c1>// We want to set c to the defaults and then overwrite it with the input.</span>
</span></span><span class=line><span class=cl>  <span class=c1>// To make unmarshal fill the plain data struct rather than calling UnmarshalYAML</span>
</span></span><span class=line><span class=cl>  <span class=c1>// again, we have to hide it using a type indirection.</span>
</span></span><span class=line><span class=cl>  <span class=kd>type</span> <span class=nx>plain</span> <span class=nx>Config</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>unmarshal</span><span class=p>((</span><span class=o>*</span><span class=nx>plain</span><span class=p>)(</span><span class=nx>c</span><span class=p>));</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// If a global block was open but empty the default global config is overwritten.</span>
</span></span><span class=line><span class=cl>  <span class=c1>// We have to restore it here.</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>GlobalConfig</span><span class=p>.</span><span class=nf>isZero</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span><span class=p>.</span><span class=nx>GlobalConfig</span> <span class=p>=</span> <span class=nx>DefaultGlobalConfig</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>rf</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span><span class=p>.</span><span class=nx>RuleFiles</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>!</span><span class=nx>patRulePath</span><span class=p>.</span><span class=nf>MatchString</span><span class=p>(</span><span class=nx>rf</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;invalid rule file path %q&#34;</span><span class=p>,</span> <span class=nx>rf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Do global overrides and validate unique names.</span>
</span></span><span class=line><span class=cl>  <span class=nx>jobNames</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>scfg</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span><span class=p>.</span><span class=nx>ScrapeConfigs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>scfg</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;empty or null scrape config section&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// First set the correct scrape interval, then check that the timeout</span>
</span></span><span class=line><span class=cl>    <span class=c1>// (inferred or explicit) is not greater than that.</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>scfg</span><span class=p>.</span><span class=nx>ScrapeInterval</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>scfg</span><span class=p>.</span><span class=nx>ScrapeInterval</span> <span class=p>=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>GlobalConfig</span><span class=p>.</span><span class=nx>ScrapeInterval</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>scfg</span><span class=p>.</span><span class=nx>ScrapeTimeout</span> <span class=p>&gt;</span> <span class=nx>scfg</span><span class=p>.</span><span class=nx>ScrapeInterval</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;scrape timeout greater than scrape interval for scrape config with job name %q&#34;</span><span class=p>,</span> <span class=nx>scfg</span><span class=p>.</span><span class=nx>JobName</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>scfg</span><span class=p>.</span><span class=nx>ScrapeTimeout</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>GlobalConfig</span><span class=p>.</span><span class=nx>ScrapeTimeout</span> <span class=p>&gt;</span> <span class=nx>scfg</span><span class=p>.</span><span class=nx>ScrapeInterval</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>scfg</span><span class=p>.</span><span class=nx>ScrapeTimeout</span> <span class=p>=</span> <span class=nx>scfg</span><span class=p>.</span><span class=nx>ScrapeInterval</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>scfg</span><span class=p>.</span><span class=nx>ScrapeTimeout</span> <span class=p>=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>GlobalConfig</span><span class=p>.</span><span class=nx>ScrapeTimeout</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>jobNames</span><span class=p>[</span><span class=nx>scfg</span><span class=p>.</span><span class=nx>JobName</span><span class=p>];</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;found multiple scrape configs with job name %q&#34;</span><span class=p>,</span> <span class=nx>scfg</span><span class=p>.</span><span class=nx>JobName</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>jobNames</span><span class=p>[</span><span class=nx>scfg</span><span class=p>.</span><span class=nx>JobName</span><span class=p>]</span> <span class=p>=</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nx>rwNames</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>rwcfg</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span><span class=p>.</span><span class=nx>RemoteWriteConfigs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>rwcfg</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;empty or null remote write config section&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Skip empty names, we fill their name with their config hash in remote write code.</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>rwNames</span><span class=p>[</span><span class=nx>rwcfg</span><span class=p>.</span><span class=nx>Name</span><span class=p>];</span> <span class=nx>ok</span> <span class=o>&amp;&amp;</span> <span class=nx>rwcfg</span><span class=p>.</span><span class=nx>Name</span> <span class=o>!=</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;found multiple remote write configs with job name %q&#34;</span><span class=p>,</span> <span class=nx>rwcfg</span><span class=p>.</span><span class=nx>Name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>rwNames</span><span class=p>[</span><span class=nx>rwcfg</span><span class=p>.</span><span class=nx>Name</span><span class=p>]</span> <span class=p>=</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nx>rrNames</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>rrcfg</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span><span class=p>.</span><span class=nx>RemoteReadConfigs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>rrcfg</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;empty or null remote read config section&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Skip empty names, we fill their name with their config hash in remote read code.</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>rrNames</span><span class=p>[</span><span class=nx>rrcfg</span><span class=p>.</span><span class=nx>Name</span><span class=p>];</span> <span class=nx>ok</span> <span class=o>&amp;&amp;</span> <span class=nx>rrcfg</span><span class=p>.</span><span class=nx>Name</span> <span class=o>!=</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;found multiple remote read configs with job name %q&#34;</span><span class=p>,</span> <span class=nx>rrcfg</span><span class=p>.</span><span class=nx>Name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>rrNames</span><span class=p>[</span><span class=nx>rrcfg</span><span class=p>.</span><span class=nx>Name</span><span class=p>]</span> <span class=p>=</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>è¿™ä¸ªé…ç½®çš„è§£æå’ŒéªŒè¯å®åœ¨æ˜¯å¤ªå¤æ‚äº†ï¼Œæˆ‘ä»¬ä¸ç®¡å…¶ä»–struct fieldçš„unmarshalï¼Œå…³æ³¨scrape configsçš„è§£æï¼Œ</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>ScrapeConfig</span><span class=p>)</span> <span class=nf>UnmarshalYAML</span><span class=p>(</span><span class=nx>unmarshal</span> <span class=kd>func</span><span class=p>(</span><span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=nx>c</span> <span class=p>=</span> <span class=nx>DefaultScrapeConfig</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>discovery</span><span class=p>.</span><span class=nf>UnmarshalYAMLWithInlineConfigs</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>unmarshal</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>JobName</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;job_name is empty&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// The UnmarshalYAML method of HTTPClientConfig is not being called because it&#39;s not a pointer.</span>
</span></span><span class=line><span class=cl>  <span class=c1>// We cannot make it a pointer as the parser panics for inlined pointer structs.</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Thus we just do its validation here.</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>HTTPClientConfig</span><span class=p>.</span><span class=nf>Validate</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Check for users putting URLs in target groups.</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>RelabelConfigs</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>checkStaticTargets</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>ServiceDiscoveryConfigs</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>rlcfg</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span><span class=p>.</span><span class=nx>RelabelConfigs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>rlcfg</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;empty or null target relabeling rule in scrape config&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>rlcfg</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span><span class=p>.</span><span class=nx>MetricRelabelConfigs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>rlcfg</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;empty or null metric relabeling rule in scrape config&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>err := discovery.UnmarshalYAMLWithInlineConfigs(c, unmarshal)</code>é‡Œé¢æ˜¯è§£æåŠ¨æ€å‘ç°çš„å…·ä½“å®ç°ï¼Œ let us drill downï¼š</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>UnmarshalYAMLWithInlineConfigs</span><span class=p>(</span><span class=nx>out</span> <span class=kd>interface</span><span class=p>{},</span> <span class=nx>unmarshal</span> <span class=kd>func</span><span class=p>(</span><span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>outVal</span> <span class=o>:=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>ValueOf</span><span class=p>(</span><span class=nx>out</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>outVal</span><span class=p>.</span><span class=nf>Kind</span><span class=p>()</span> <span class=o>!=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Ptr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;discovery: can only unmarshal into a struct pointer: %T&#34;</span><span class=p>,</span> <span class=nx>out</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nx>outVal</span> <span class=p>=</span> <span class=nx>outVal</span><span class=p>.</span><span class=nf>Elem</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>outVal</span><span class=p>.</span><span class=nf>Kind</span><span class=p>()</span> <span class=o>!=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;discovery: can only unmarshal into a struct pointer: %T&#34;</span><span class=p>,</span> <span class=nx>out</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nx>outTyp</span> <span class=o>:=</span> <span class=nx>outVal</span><span class=p>.</span><span class=nf>Type</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>cfgTyp</span> <span class=o>:=</span> <span class=nf>getConfigType</span><span class=p>(</span><span class=nx>outTyp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>cfgPtr</span> <span class=o>:=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=nx>cfgTyp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>cfgVal</span> <span class=o>:=</span> <span class=nx>cfgPtr</span><span class=p>.</span><span class=nf>Elem</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Copy shared fields (defaults) to dynamic value.</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>configs</span> <span class=o>*</span><span class=nx>Configs</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>n</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>outVal</span><span class=p>.</span><span class=nf>NumField</span><span class=p>();</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>outTyp</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>).</span><span class=nx>Type</span> <span class=o>==</span> <span class=nx>configsType</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>configs</span> <span class=p>=</span> <span class=nx>outVal</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>).</span><span class=nf>Addr</span><span class=p>().</span><span class=nf>Interface</span><span class=p>().(</span><span class=o>*</span><span class=nx>Configs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>continue</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>cfgTyp</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>).</span><span class=nx>PkgPath</span> <span class=o>!=</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>continue</span> <span class=c1>// Field is unexported: ignore.</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>cfgVal</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>).</span><span class=nf>Set</span><span class=p>(</span><span class=nx>outVal</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>configs</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;discovery: Configs field not found in type: %T&#34;</span><span class=p>,</span> <span class=nx>out</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Unmarshal into dynamic value.</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>unmarshal</span><span class=p>(</span><span class=nx>cfgPtr</span><span class=p>.</span><span class=nf>Interface</span><span class=p>());</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>replaceYAMLTypeError</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=nx>cfgTyp</span><span class=p>,</span> <span class=nx>outTyp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Copy shared fields from dynamic value.</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>n</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>outVal</span><span class=p>.</span><span class=nf>NumField</span><span class=p>();</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>cfgTyp</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>).</span><span class=nx>PkgPath</span> <span class=o>!=</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>continue</span> <span class=c1>// Field is unexported: ignore.</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>outVal</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>).</span><span class=nf>Set</span><span class=p>(</span><span class=nx>cfgVal</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>err</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=nx>configs</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nf>readConfigs</span><span class=p>(</span><span class=nx>cfgVal</span><span class=p>,</span> <span class=nx>outVal</span><span class=p>.</span><span class=nf>NumField</span><span class=p>())</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Oh, my god! è¿™ä¸ªå¤ªåˆºæ¿€äº†ï¼Œç”¨reflectå»å®ç°åº•å±‚çš„æ•°æ®è§£æï¼Œè¿™ä¸ªä»¥åè¦çœ‹çœ‹åº•å±‚çš„å®ç°ï¼Œå…ˆä¸ç®¡äº†ï¼Œæˆ‘ä»¬çœ‹åˆ°ä¸Šé¢å‡½æ•°çš„å€’æ•°ç¬¬äºŒå¥æœ‰è¿™æ ·ä¸€ä¸ªè°ƒç”¨<code>*configs, err = readConfigs(cfgVal, outVal.NumField())</code>ï¼Œç»§ç»­drill down</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>readConfigs</span><span class=p>(</span><span class=nx>structVal</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Value</span><span class=p>,</span> <span class=nx>startField</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>Configs</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>configs</span> <span class=nx>Configs</span>
</span></span><span class=line><span class=cl>    <span class=nx>targets</span> <span class=p>[]</span><span class=o>*</span><span class=nx>targetgroup</span><span class=p>.</span><span class=nx>Group</span>
</span></span><span class=line><span class=cl>  <span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>n</span> <span class=o>:=</span> <span class=nx>startField</span><span class=p>,</span> <span class=nx>structVal</span><span class=p>.</span><span class=nf>NumField</span><span class=p>();</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>field</span> <span class=o>:=</span> <span class=nx>structVal</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>field</span><span class=p>.</span><span class=nf>Kind</span><span class=p>()</span> <span class=o>!=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Slice</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nb>panic</span><span class=p>(</span><span class=s>&#34;discovery: internal error: field is not a slice&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>k</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>k</span> <span class=p>&lt;</span> <span class=nx>field</span><span class=p>.</span><span class=nf>Len</span><span class=p>();</span> <span class=nx>k</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>val</span> <span class=o>:=</span> <span class=nx>field</span><span class=p>.</span><span class=nf>Index</span><span class=p>(</span><span class=nx>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nx>val</span><span class=p>.</span><span class=nf>IsZero</span><span class=p>()</span> <span class=o>||</span> <span class=p>(</span><span class=nx>val</span><span class=p>.</span><span class=nf>Kind</span><span class=p>()</span> <span class=o>==</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Ptr</span> <span class=o>&amp;&amp;</span> <span class=nx>val</span><span class=p>.</span><span class=nf>Elem</span><span class=p>().</span><span class=nf>IsZero</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>key</span> <span class=o>:=</span> <span class=nx>configFieldNames</span><span class=p>[</span><span class=nx>field</span><span class=p>.</span><span class=nf>Type</span><span class=p>().</span><span class=nf>Elem</span><span class=p>()]</span>
</span></span><span class=line><span class=cl>        <span class=nx>key</span> <span class=p>=</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>TrimPrefix</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>configFieldPrefix</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;empty or null section in %s&#34;</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=k>switch</span> <span class=nx>c</span> <span class=o>:=</span> <span class=nx>val</span><span class=p>.</span><span class=nf>Interface</span><span class=p>().(</span><span class=kd>type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=o>*</span><span class=nx>targetgroup</span><span class=p>.</span><span class=nx>Group</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Add index to the static config target groups for unique identification</span>
</span></span><span class=line><span class=cl>        <span class=c1>// within scrape pool.</span>
</span></span><span class=line><span class=cl>        <span class=nx>c</span><span class=p>.</span><span class=nx>Source</span> <span class=p>=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>Itoa</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>targets</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Coalesce multiple static configs into a single static config.</span>
</span></span><span class=line><span class=cl>        <span class=nx>targets</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>targets</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nx>Config</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nx>configs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>configs</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=s>&#34;discovery: internal error: slice element is not a Config&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>targets</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>configs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>configs</span><span class=p>,</span> <span class=nf>StaticConfig</span><span class=p>(</span><span class=nx>targets</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>configs</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>å‰å®³äº†å‰å®³äº†ï¼Œæˆ‘ä»¬ç»ˆäºè§£æå®Œäº†scrape configï¼Œç»ˆäºçŸ¥é“å¯ä»¥å»æŠ“å–å“ªäº›ç›®æ ‡metricsäº†ã€‚å—¯ï¼Œåˆæœ‰æ–°ç›®æ ‡ï¼Œäº†è§£yamlåº•å±‚è§£æçš„åŸç†ï¼ï¼ï¼</p><p>ä¸‹ä¸€ç¯‡æˆ‘ä»¬æ¥ç€ç ”ç©¶Prometheus serverçš„scrapeå®ç°ã€‚</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://solaim.github.io/tags/golang/>Golang</a></li><li><a href=https://solaim.github.io/tags/prometheus/>Prometheus</a></li><li><a href=https://solaim.github.io/tags/observability/>Observability</a></li></ul><nav class=paginav><a class=prev href=https://solaim.github.io/posts/prometheus%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%9B%9B/><span class=title>Â« Prev</span><br><span>Prometheuså†…éƒ¨å®ç°(å››)</span>
</a><a class=next href=https://solaim.github.io/posts/prometheus%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E4%BA%8C/><span class=title>Next Â»</span><br><span>Prometheuså†…éƒ¨å®ç°(äºŒ)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://solaim.github.io/>Jerry Wang</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>