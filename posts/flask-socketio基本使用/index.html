<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Flask SocketIO基本使用 | Jerry Wang</title>
<meta name=keywords content="Python,Flask,SocketIO"><meta name=description content="Flask-SocketIO是一个用于建立WebSocket全双工通信的Flask扩展。客户端应用可以使用任一SocketIO官方客户端库实现，或可以建立持久连接的兼容客户端实现。
1.安装

pip install flask-socketio
Flask-SocketIO提供三种异步服务机制：

eventlet：支持长轮询和websocket
gevent：需使用第三方库
Werkzeug：仅支持长轮询

2.初始化
from flask import Flask, render_template
from flask_socketio import SocketIO

app = Flask(__name__)
app.config['SECRET_KEY'] = 'secret!'
socketio = SocketIO(app)

if __name__ == '__main__':
    socketio.run(app)
应用必须给客户端返回一个html页面加载SocketIO库，并且建立连接：
<script type=&#34;text/javascript&#34; src=&#34;//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js&#34;></script>
<script type=&#34;text/javascript&#34; charset=&#34;utf-8&#34;>
    var socket = io.connect('http://' + document.domain + ':' + location.port);
    socket.on('connect', function() {
        socket.emit('my event', {data: 'I\'m connected!'});
    });
</script>
3.接收消息
使用SocketIO时，客户端和服务端以事件的方式接收消息-事件驱动。在客户端，javascript使用回调函数。在服务端，Flask-SocketIO需要注册事件处理函数，类似于路由-视图函数机制。
下面的例子创建服务端无名事件处理函数：
@socketio.on('message')
def handle_message(message):
    print('received message: ' + message)
上面的例子使用字符串消息，也可以使用json格式的消息：
@socketio.on('json')
def handle_json(json):
    print('received json: ' + str(json))
最灵活的事件类型是使用定制事件名称。这些事件的消息数据格式可以是字符串、字节、整数或者json：
@socketio.on('my event')
def handle_my_custom_event(json):
    print('received json: ' + str(json))
定制的命名事件支持多参数：
@socketio.on('my event')
def handle_my_custom_event(arg1, arg2, arg3):
    print('received args: ' + arg1 + arg2 + arg3)
命名事件是最灵活的，因为命名事件消除了包含附加元数据（描述消息类型）的需要。Flask-socketIO也支持SocketIO命名域，SocketIO命名域允许客户端复用socket（多个连接建立在同一物理socket）。
@socketio.on('my event', namespace='/test')
def handle_my_custom_namespace_event(json):
    print('received json: ' + str(json))
当SocketIO没有显式指定命名域，全局命名域‘／’将会被使用。
当装饰器语法不太合适时，on_event方法可被使用：
def my_function_handler(data):
    pass

socketio.on_event('my event', my_function_handler, namespace='/test')
客户端可能请求一个承认的回调函数，该函数确认接收发送的消息。处理函数的任何返回值将会作为参数递送给客户端的回调函数："><meta name=author content="Jerry Wang"><link rel=canonical href=https://solaim.github.io/posts/flask-socketio%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://solaim.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://solaim.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://solaim.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://solaim.github.io/apple-touch-icon.png><link rel=mask-icon href=https://solaim.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://solaim.github.io/posts/flask-socketio%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://solaim.github.io/posts/flask-socketio%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"><meta property="og:site_name" content="Jerry Wang"><meta property="og:title" content="Flask SocketIO基本使用"><meta property="og:description" content="Flask-SocketIO是一个用于建立WebSocket全双工通信的Flask扩展。客户端应用可以使用任一SocketIO官方客户端库实现，或可以建立持久连接的兼容客户端实现。
1.安装 pip install flask-socketio
Flask-SocketIO提供三种异步服务机制：
eventlet：支持长轮询和websocket gevent：需使用第三方库 Werkzeug：仅支持长轮询 2.初始化 from flask import Flask, render_template from flask_socketio import SocketIO app = Flask(__name__) app.config['SECRET_KEY'] = 'secret!' socketio = SocketIO(app) if __name__ == '__main__': socketio.run(app) 应用必须给客户端返回一个html页面加载SocketIO库，并且建立连接：
<script type=&#34;text/javascript&#34; src=&#34;//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js&#34;></script> <script type=&#34;text/javascript&#34; charset=&#34;utf-8&#34;> var socket = io.connect('http://' + document.domain + ':' + location.port); socket.on('connect', function() { socket.emit('my event', {data: 'I\'m connected!'}); }); </script> 3.接收消息 使用SocketIO时，客户端和服务端以事件的方式接收消息-事件驱动。在客户端，javascript使用回调函数。在服务端，Flask-SocketIO需要注册事件处理函数，类似于路由-视图函数机制。
下面的例子创建服务端无名事件处理函数：
@socketio.on('message') def handle_message(message): print('received message: ' + message) 上面的例子使用字符串消息，也可以使用json格式的消息：
@socketio.on('json') def handle_json(json): print('received json: ' + str(json)) 最灵活的事件类型是使用定制事件名称。这些事件的消息数据格式可以是字符串、字节、整数或者json：
@socketio.on('my event') def handle_my_custom_event(json): print('received json: ' + str(json)) 定制的命名事件支持多参数：
@socketio.on('my event') def handle_my_custom_event(arg1, arg2, arg3): print('received args: ' + arg1 + arg2 + arg3) 命名事件是最灵活的，因为命名事件消除了包含附加元数据（描述消息类型）的需要。Flask-socketIO也支持SocketIO命名域，SocketIO命名域允许客户端复用socket（多个连接建立在同一物理socket）。
@socketio.on('my event', namespace='/test') def handle_my_custom_namespace_event(json): print('received json: ' + str(json)) 当SocketIO没有显式指定命名域，全局命名域‘／’将会被使用。
当装饰器语法不太合适时，on_event方法可被使用：
def my_function_handler(data): pass socketio.on_event('my event', my_function_handler, namespace='/test') 客户端可能请求一个承认的回调函数，该函数确认接收发送的消息。处理函数的任何返回值将会作为参数递送给客户端的回调函数："><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-04-11T21:22:26+08:00"><meta property="article:modified_time" content="2019-04-11T21:22:26+08:00"><meta property="article:tag" content="Python"><meta property="article:tag" content="Flask"><meta property="article:tag" content="SocketIO"><meta property="og:image" content="https://solaim.github.io/img/favicon.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://solaim.github.io/img/favicon.webp"><meta name=twitter:title content="Flask SocketIO基本使用"><meta name=twitter:description content="Flask-SocketIO是一个用于建立WebSocket全双工通信的Flask扩展。客户端应用可以使用任一SocketIO官方客户端库实现，或可以建立持久连接的兼容客户端实现。
1.安装

pip install flask-socketio
Flask-SocketIO提供三种异步服务机制：

eventlet：支持长轮询和websocket
gevent：需使用第三方库
Werkzeug：仅支持长轮询

2.初始化
from flask import Flask, render_template
from flask_socketio import SocketIO

app = Flask(__name__)
app.config['SECRET_KEY'] = 'secret!'
socketio = SocketIO(app)

if __name__ == '__main__':
    socketio.run(app)
应用必须给客户端返回一个html页面加载SocketIO库，并且建立连接：
<script type=&#34;text/javascript&#34; src=&#34;//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js&#34;></script>
<script type=&#34;text/javascript&#34; charset=&#34;utf-8&#34;>
    var socket = io.connect('http://' + document.domain + ':' + location.port);
    socket.on('connect', function() {
        socket.emit('my event', {data: 'I\'m connected!'});
    });
</script>
3.接收消息
使用SocketIO时，客户端和服务端以事件的方式接收消息-事件驱动。在客户端，javascript使用回调函数。在服务端，Flask-SocketIO需要注册事件处理函数，类似于路由-视图函数机制。
下面的例子创建服务端无名事件处理函数：
@socketio.on('message')
def handle_message(message):
    print('received message: ' + message)
上面的例子使用字符串消息，也可以使用json格式的消息：
@socketio.on('json')
def handle_json(json):
    print('received json: ' + str(json))
最灵活的事件类型是使用定制事件名称。这些事件的消息数据格式可以是字符串、字节、整数或者json：
@socketio.on('my event')
def handle_my_custom_event(json):
    print('received json: ' + str(json))
定制的命名事件支持多参数：
@socketio.on('my event')
def handle_my_custom_event(arg1, arg2, arg3):
    print('received args: ' + arg1 + arg2 + arg3)
命名事件是最灵活的，因为命名事件消除了包含附加元数据（描述消息类型）的需要。Flask-socketIO也支持SocketIO命名域，SocketIO命名域允许客户端复用socket（多个连接建立在同一物理socket）。
@socketio.on('my event', namespace='/test')
def handle_my_custom_namespace_event(json):
    print('received json: ' + str(json))
当SocketIO没有显式指定命名域，全局命名域‘／’将会被使用。
当装饰器语法不太合适时，on_event方法可被使用：
def my_function_handler(data):
    pass

socketio.on_event('my event', my_function_handler, namespace='/test')
客户端可能请求一个承认的回调函数，该函数确认接收发送的消息。处理函数的任何返回值将会作为参数递送给客户端的回调函数："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://solaim.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Flask SocketIO基本使用","item":"https://solaim.github.io/posts/flask-socketio%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Flask SocketIO基本使用","name":"Flask SocketIO基本使用","description":"Flask-SocketIO是一个用于建立WebSocket全双工通信的Flask扩展。客户端应用可以使用任一SocketIO官方客户端库实现，或可以建立持久连接的兼容客户端实现。\n1.安装 pip install flask-socketio\nFlask-SocketIO提供三种异步服务机制：\neventlet：支持长轮询和websocket gevent：需使用第三方库 Werkzeug：仅支持长轮询 2.初始化 from flask import Flask, render_template from flask_socketio import SocketIO app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = \u0026#39;secret!\u0026#39; socketio = SocketIO(app) if __name__ == \u0026#39;__main__\u0026#39;: socketio.run(app) 应用必须给客户端返回一个html页面加载SocketIO库，并且建立连接：\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; charset=\u0026#34;utf-8\u0026#34;\u0026gt; var socket = io.connect(\u0026#39;http://\u0026#39; + document.domain + \u0026#39;:\u0026#39; + location.port); socket.on(\u0026#39;connect\u0026#39;, function() { socket.emit(\u0026#39;my event\u0026#39;, {data: \u0026#39;I\\\u0026#39;m connected!\u0026#39;}); }); \u0026lt;/script\u0026gt; 3.接收消息 使用SocketIO时，客户端和服务端以事件的方式接收消息-事件驱动。在客户端，javascript使用回调函数。在服务端，Flask-SocketIO需要注册事件处理函数，类似于路由-视图函数机制。\n下面的例子创建服务端无名事件处理函数：\n@socketio.on(\u0026#39;message\u0026#39;) def handle_message(message): print(\u0026#39;received message: \u0026#39; + message) 上面的例子使用字符串消息，也可以使用json格式的消息：\n@socketio.on(\u0026#39;json\u0026#39;) def handle_json(json): print(\u0026#39;received json: \u0026#39; + str(json)) 最灵活的事件类型是使用定制事件名称。这些事件的消息数据格式可以是字符串、字节、整数或者json：\n@socketio.on(\u0026#39;my event\u0026#39;) def handle_my_custom_event(json): print(\u0026#39;received json: \u0026#39; + str(json)) 定制的命名事件支持多参数：\n@socketio.on(\u0026#39;my event\u0026#39;) def handle_my_custom_event(arg1, arg2, arg3): print(\u0026#39;received args: \u0026#39; + arg1 + arg2 + arg3) 命名事件是最灵活的，因为命名事件消除了包含附加元数据（描述消息类型）的需要。Flask-socketIO也支持SocketIO命名域，SocketIO命名域允许客户端复用socket（多个连接建立在同一物理socket）。\n@socketio.on(\u0026#39;my event\u0026#39;, namespace=\u0026#39;/test\u0026#39;) def handle_my_custom_namespace_event(json): print(\u0026#39;received json: \u0026#39; + str(json)) 当SocketIO没有显式指定命名域，全局命名域‘／’将会被使用。\n当装饰器语法不太合适时，on_event方法可被使用：\ndef my_function_handler(data): pass socketio.on_event(\u0026#39;my event\u0026#39;, my_function_handler, namespace=\u0026#39;/test\u0026#39;) 客户端可能请求一个承认的回调函数，该函数确认接收发送的消息。处理函数的任何返回值将会作为参数递送给客户端的回调函数：\n","keywords":["Python","Flask","SocketIO"],"articleBody":"Flask-SocketIO是一个用于建立WebSocket全双工通信的Flask扩展。客户端应用可以使用任一SocketIO官方客户端库实现，或可以建立持久连接的兼容客户端实现。\n1.安装 pip install flask-socketio\nFlask-SocketIO提供三种异步服务机制：\neventlet：支持长轮询和websocket gevent：需使用第三方库 Werkzeug：仅支持长轮询 2.初始化 from flask import Flask, render_template from flask_socketio import SocketIO app = Flask(__name__) app.config['SECRET_KEY'] = 'secret!' socketio = SocketIO(app) if __name__ == '__main__': socketio.run(app) 应用必须给客户端返回一个html页面加载SocketIO库，并且建立连接：\n\u003cscript type=\"text/javascript\" src=\"//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" charset=\"utf-8\"\u003e var socket = io.connect('http://' + document.domain + ':' + location.port); socket.on('connect', function() { socket.emit('my event', {data: 'I\\'m connected!'}); }); \u003c/script\u003e 3.接收消息 使用SocketIO时，客户端和服务端以事件的方式接收消息-事件驱动。在客户端，javascript使用回调函数。在服务端，Flask-SocketIO需要注册事件处理函数，类似于路由-视图函数机制。\n下面的例子创建服务端无名事件处理函数：\n@socketio.on('message') def handle_message(message): print('received message: ' + message) 上面的例子使用字符串消息，也可以使用json格式的消息：\n@socketio.on('json') def handle_json(json): print('received json: ' + str(json)) 最灵活的事件类型是使用定制事件名称。这些事件的消息数据格式可以是字符串、字节、整数或者json：\n@socketio.on('my event') def handle_my_custom_event(json): print('received json: ' + str(json)) 定制的命名事件支持多参数：\n@socketio.on('my event') def handle_my_custom_event(arg1, arg2, arg3): print('received args: ' + arg1 + arg2 + arg3) 命名事件是最灵活的，因为命名事件消除了包含附加元数据（描述消息类型）的需要。Flask-socketIO也支持SocketIO命名域，SocketIO命名域允许客户端复用socket（多个连接建立在同一物理socket）。\n@socketio.on('my event', namespace='/test') def handle_my_custom_namespace_event(json): print('received json: ' + str(json)) 当SocketIO没有显式指定命名域，全局命名域‘／’将会被使用。\n当装饰器语法不太合适时，on_event方法可被使用：\ndef my_function_handler(data): pass socketio.on_event('my event', my_function_handler, namespace='/test') 客户端可能请求一个承认的回调函数，该函数确认接收发送的消息。处理函数的任何返回值将会作为参数递送给客户端的回调函数：\n@socketio.on('my event') def handle_my_custom_event(json): print('received json: ' + str(json)) return 'one', 2 上例中，客户端回调函数将会被传递两个参数：‘one’和2。\n4、发送消息 Socket IO事件处理函数可以发送回复消息至连接的客户端，方法包括send()和emit()。\nfrom flask_socketio import send, emit @socketio.on('message') def handle_message(message): send(message) @socketio.on('json') def handle_json(json): send(json, json=True) @socketio.on('my event') def handle_my_custom_event(json): emit('my response', json) 当使用命名域时，send和emit默认使用接收消息的命名域。不同的命名域可以通过namespace参数指定。\n@socketio.on('message') def handle_message(message): send(message, namespace='/chat') @socketio.on('my event') def handle_my_custom_event(json): emit('my response', json, namespace='/chat') 当使用多个参数回复一个事件时，发送一个tuple：\n@socketio.on('my event') def handle_my_custom_event(json): emit('my response', ('foo', 'bar', json), namespace='/chat') SocketIO支持回调函数，该函数用于证实客户端成功接收了消息：\ndef ack(): print 'message was received!' @socketio.on('my event') def handle_my_custom_event(json): emit('my response', json, callback=ack) 当使用回调函数时，js客户端从接收的消息中获取回调函数，客户端回调函数唤起之后服务端的回调函数相应地被唤起。如歌客户端回调函数具有参数，服务端的回调函数具有相同的参数。\n5、广播 Flask-SocketIO支持广播，只需在send和emit函数中添加关键字参数broadcast=True：\n@socketio.on('my event') def handle_my_custom_event(data): emit('my response', data, broadcast=True) 对于服务端主动发起的广播，socketio.send()和socketio.emit()方法可以用来广播消息至所有连接的客户端。\ndef some_function(): socketio.emit('some event', {'data': 42}) 6、Rooms Flask-SocketIO通过join_room和leave_room函数支持room概念。\nfrom flask_socketio import join_room, leave_room @socketio.on('join') def on_join(data): username = data['username'] room = data['room'] join_room(room) send(username + ' has entered the room.', room=room) @socketio.on('leave') def on_leave(data): username = data['username'] room = data['room'] leave_room(room) send(username + ' has left the room.', room=room) send和emit函数接收关键字参数room，将消息发送至连接对应room的客户端。\n所有的客户端连接room时用session ID命名，可以使用request.sid获取。\n7、连接事件 Flask-SocketIO也支持连接和连接断开事件。\n@socketio.on('connect', namespace='/chat') def test_connect(): emit('my response', {'data': 'Connected'}) @socketio.on('disconnect', namespace='/chat') def test_disconnect(): print('Client disconnected') 8、基于类的命名域 上面描述的是基于装饰器的处理函数，也可以使用基于类的命名域处理函数。\nfrom flask_socketio import Namespace, emit class MyCustomNamespace(Namespace): def on_connect(self): pass def on_disconnect(self): pass def on_my_event(self, data): emit('my_response', data) socketio.on_namespace(MyCustomNamespace('/test')) 9、错误处理 @socketio.on_error() # Handles the default namespace def error_handler(e): pass @socketio.on_error('/chat') # handles the '/chat' namespace def error_handler_chat(e): pass @socketio.on_error_default # handles all namespaces without an explicit error handler def default_error_handler(e): pass ","wordCount":"337","inLanguage":"en","image":"https://solaim.github.io/img/favicon.webp","datePublished":"2019-04-11T21:22:26+08:00","dateModified":"2019-04-11T21:22:26+08:00","author":{"@type":"Person","name":"Jerry Wang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://solaim.github.io/posts/flask-socketio%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},"publisher":{"@type":"Organization","name":"Jerry Wang","logo":{"@type":"ImageObject","url":"https://solaim.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://solaim.github.io/ accesskey=h title="首页 (Alt + H)"><img src=https://solaim.github.io/apple-touch-icon.png alt aria-label=logo height=35>首页</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://solaim.github.io/categories/ title=🕸分类><span>🕸分类</span></a></li><li><a href=https://solaim.github.io/tags/ title=🐚标签><span>🐚标签</span></a></li><li><a href=https://solaim.github.io/about/ title=🌏关于><span>🌏关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://solaim.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://solaim.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Flask SocketIO基本使用</h1><div class=post-meta><span title='2019-04-11 21:22:26 +0800 +0800'>2019-04-11</span>&nbsp;·&nbsp;Jerry Wang</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1安装>1.安装</a></li><li><a href=#2初始化>2.初始化</a></li><li><a href=#3接收消息>3.接收消息</a></li><li><a href=#4发送消息>4、发送消息</a></li><li><a href=#5广播>5、广播</a></li><li><a href=#6rooms>6、Rooms</a></li><li><a href=#7连接事件>7、连接事件</a></li><li><a href=#8基于类的命名域>8、基于类的命名域</a></li><li><a href=#9错误处理>9、错误处理</a></li></ul></nav></div></details></div><div class=post-content><p>Flask-SocketIO是一个用于建立WebSocket全双工通信的Flask扩展。客户端应用可以使用任一SocketIO官方客户端库实现，或可以建立持久连接的兼容客户端实现。</p><h2 id=1安装>1.安装<a hidden class=anchor aria-hidden=true href=#1安装>#</a></h2><blockquote><p>pip install flask-socketio</p></blockquote><p>Flask-SocketIO提供三种异步服务机制：</p><ul><li>eventlet：支持长轮询和websocket</li><li>gevent：需使用第三方库</li><li>Werkzeug：仅支持长轮询</li></ul><h2 id=2初始化>2.初始化<a hidden class=anchor aria-hidden=true href=#2初始化>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>flask</span> <span class=kn>import</span> <span class=n>Flask</span><span class=p>,</span> <span class=n>render_template</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>flask_socketio</span> <span class=kn>import</span> <span class=n>SocketIO</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>app</span> <span class=o>=</span> <span class=n>Flask</span><span class=p>(</span><span class=vm>__name__</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>app</span><span class=o>.</span><span class=n>config</span><span class=p>[</span><span class=s1>&#39;SECRET_KEY&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=s1>&#39;secret!&#39;</span>
</span></span><span class=line><span class=cl><span class=n>socketio</span> <span class=o>=</span> <span class=n>SocketIO</span><span class=p>(</span><span class=n>app</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>&#39;__main__&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>socketio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>app</span><span class=p>)</span>
</span></span></code></pre></div><p>应用必须给客户端返回一个html页面加载SocketIO库，并且建立连接：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>script</span> <span class=nx>type</span><span class=o>=</span><span class=s2>&#34;text/javascript&#34;</span> <span class=nx>src</span><span class=o>=</span><span class=s2>&#34;//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js&#34;</span><span class=o>&gt;&lt;</span><span class=err>/script&gt;</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>script</span> <span class=nx>type</span><span class=o>=</span><span class=s2>&#34;text/javascript&#34;</span> <span class=nx>charset</span><span class=o>=</span><span class=s2>&#34;utf-8&#34;</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>socket</span> <span class=o>=</span> <span class=nx>io</span><span class=p>.</span><span class=nx>connect</span><span class=p>(</span><span class=s1>&#39;http://&#39;</span> <span class=o>+</span> <span class=nb>document</span><span class=p>.</span><span class=nx>domain</span> <span class=o>+</span> <span class=s1>&#39;:&#39;</span> <span class=o>+</span> <span class=nx>location</span><span class=p>.</span><span class=nx>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>socket</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;connect&#39;</span><span class=p>,</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>socket</span><span class=p>.</span><span class=nx>emit</span><span class=p>(</span><span class=s1>&#39;my event&#39;</span><span class=p>,</span> <span class=p>{</span><span class=nx>data</span><span class=o>:</span> <span class=s1>&#39;I\&#39;m connected!&#39;</span><span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=err>/script&gt;</span>
</span></span></code></pre></div><h2 id=3接收消息>3.接收消息<a hidden class=anchor aria-hidden=true href=#3接收消息>#</a></h2><p>使用SocketIO时，客户端和服务端以事件的方式接收消息-事件驱动。在客户端，javascript使用回调函数。在服务端，Flask-SocketIO需要注册事件处理函数，类似于路由-视图函数机制。</p><p>下面的例子创建服务端无名事件处理函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nd>@socketio.on</span><span class=p>(</span><span class=s1>&#39;message&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>handle_message</span><span class=p>(</span><span class=n>message</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;received message: &#39;</span> <span class=o>+</span> <span class=n>message</span><span class=p>)</span>
</span></span></code></pre></div><p>上面的例子使用字符串消息，也可以使用json格式的消息：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nd>@socketio.on</span><span class=p>(</span><span class=s1>&#39;json&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>handle_json</span><span class=p>(</span><span class=n>json</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;received json: &#39;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>json</span><span class=p>))</span>
</span></span></code></pre></div><p>最灵活的事件类型是使用定制事件名称。这些事件的消息数据格式可以是字符串、字节、整数或者json：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nd>@socketio.on</span><span class=p>(</span><span class=s1>&#39;my event&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>handle_my_custom_event</span><span class=p>(</span><span class=n>json</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;received json: &#39;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>json</span><span class=p>))</span>
</span></span></code></pre></div><p>定制的命名事件支持多参数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nd>@socketio.on</span><span class=p>(</span><span class=s1>&#39;my event&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>handle_my_custom_event</span><span class=p>(</span><span class=n>arg1</span><span class=p>,</span> <span class=n>arg2</span><span class=p>,</span> <span class=n>arg3</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;received args: &#39;</span> <span class=o>+</span> <span class=n>arg1</span> <span class=o>+</span> <span class=n>arg2</span> <span class=o>+</span> <span class=n>arg3</span><span class=p>)</span>
</span></span></code></pre></div><p>命名事件是最灵活的，因为命名事件消除了包含附加元数据（描述消息类型）的需要。Flask-socketIO也支持SocketIO命名域，SocketIO命名域允许客户端复用socket（多个连接建立在同一物理socket）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nd>@socketio.on</span><span class=p>(</span><span class=s1>&#39;my event&#39;</span><span class=p>,</span> <span class=n>namespace</span><span class=o>=</span><span class=s1>&#39;/test&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>handle_my_custom_namespace_event</span><span class=p>(</span><span class=n>json</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;received json: &#39;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>json</span><span class=p>))</span>
</span></span></code></pre></div><p>当SocketIO没有显式指定命名域，全局命名域‘／’将会被使用。</p><p>当装饰器语法不太合适时，on_event方法可被使用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>my_function_handler</span><span class=p>(</span><span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>socketio</span><span class=o>.</span><span class=n>on_event</span><span class=p>(</span><span class=s1>&#39;my event&#39;</span><span class=p>,</span> <span class=n>my_function_handler</span><span class=p>,</span> <span class=n>namespace</span><span class=o>=</span><span class=s1>&#39;/test&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p>客户端可能请求一个承认的回调函数，该函数确认接收发送的消息。处理函数的任何返回值将会作为参数递送给客户端的回调函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=err>@</span><span class=n>socketio</span><span class=p>.</span><span class=nf>on</span><span class=p>(</span><span class=err>&#39;</span><span class=n>my</span> <span class=n>event</span><span class=err>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>def</span> <span class=nf>handle_my_custom_event</span><span class=p>(</span><span class=n>json</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nf>print</span><span class=p>(</span><span class=err>&#39;</span><span class=n>received</span> <span class=nl>json</span><span class=p>:</span> <span class=err>&#39;</span> <span class=o>+</span> <span class=nf>str</span><span class=p>(</span><span class=n>json</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=err>&#39;</span><span class=n>one</span><span class=err>&#39;</span><span class=p>,</span> <span class=mi>2</span>
</span></span></code></pre></div><p>上例中，客户端回调函数将会被传递两个参数：‘one&rsquo;和2。</p><h2 id=4发送消息>4、发送消息<a hidden class=anchor aria-hidden=true href=#4发送消息>#</a></h2><p>Socket IO事件处理函数可以发送回复消息至连接的客户端，方法包括send()和emit()。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>flask_socketio</span> <span class=kn>import</span> <span class=n>send</span><span class=p>,</span> <span class=n>emit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@socketio.on</span><span class=p>(</span><span class=s1>&#39;message&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>handle_message</span><span class=p>(</span><span class=n>message</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>send</span><span class=p>(</span><span class=n>message</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@socketio.on</span><span class=p>(</span><span class=s1>&#39;json&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>handle_json</span><span class=p>(</span><span class=n>json</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>send</span><span class=p>(</span><span class=n>json</span><span class=p>,</span> <span class=n>json</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@socketio.on</span><span class=p>(</span><span class=s1>&#39;my event&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>handle_my_custom_event</span><span class=p>(</span><span class=n>json</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>emit</span><span class=p>(</span><span class=s1>&#39;my response&#39;</span><span class=p>,</span> <span class=n>json</span><span class=p>)</span>
</span></span></code></pre></div><p>当使用命名域时，send和emit默认使用接收消息的命名域。不同的命名域可以通过namespace参数指定。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nd>@socketio.on</span><span class=p>(</span><span class=s1>&#39;message&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>handle_message</span><span class=p>(</span><span class=n>message</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>send</span><span class=p>(</span><span class=n>message</span><span class=p>,</span> <span class=n>namespace</span><span class=o>=</span><span class=s1>&#39;/chat&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@socketio.on</span><span class=p>(</span><span class=s1>&#39;my event&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>handle_my_custom_event</span><span class=p>(</span><span class=n>json</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>emit</span><span class=p>(</span><span class=s1>&#39;my response&#39;</span><span class=p>,</span> <span class=n>json</span><span class=p>,</span> <span class=n>namespace</span><span class=o>=</span><span class=s1>&#39;/chat&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p>当使用多个参数回复一个事件时，发送一个tuple：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nd>@socketio.on</span><span class=p>(</span><span class=s1>&#39;my event&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>handle_my_custom_event</span><span class=p>(</span><span class=n>json</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>emit</span><span class=p>(</span><span class=s1>&#39;my response&#39;</span><span class=p>,</span> <span class=p>(</span><span class=s1>&#39;foo&#39;</span><span class=p>,</span> <span class=s1>&#39;bar&#39;</span><span class=p>,</span> <span class=n>json</span><span class=p>),</span> <span class=n>namespace</span><span class=o>=</span><span class=s1>&#39;/chat&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p>SocketIO支持回调函数，该函数用于证实客户端成功接收了消息：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>ack</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span> <span class=s1>&#39;message was received!&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@socketio.on</span><span class=p>(</span><span class=s1>&#39;my event&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>handle_my_custom_event</span><span class=p>(</span><span class=n>json</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>emit</span><span class=p>(</span><span class=s1>&#39;my response&#39;</span><span class=p>,</span> <span class=n>json</span><span class=p>,</span> <span class=n>callback</span><span class=o>=</span><span class=n>ack</span><span class=p>)</span>
</span></span></code></pre></div><p>当使用回调函数时，js客户端从接收的消息中获取回调函数，客户端回调函数唤起之后服务端的回调函数相应地被唤起。如歌客户端回调函数具有参数，服务端的回调函数具有相同的参数。</p><h2 id=5广播>5、广播<a hidden class=anchor aria-hidden=true href=#5广播>#</a></h2><p>Flask-SocketIO支持广播，只需在send和emit函数中添加关键字参数broadcast=True：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nd>@socketio.on</span><span class=p>(</span><span class=s1>&#39;my event&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>handle_my_custom_event</span><span class=p>(</span><span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>emit</span><span class=p>(</span><span class=s1>&#39;my response&#39;</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=n>broadcast</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span></code></pre></div><p>对于服务端主动发起的广播，socketio.send()和socketio.emit()方法可以用来广播消息至所有连接的客户端。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>some_function</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>socketio</span><span class=o>.</span><span class=n>emit</span><span class=p>(</span><span class=s1>&#39;some event&#39;</span><span class=p>,</span> <span class=p>{</span><span class=s1>&#39;data&#39;</span><span class=p>:</span> <span class=mi>42</span><span class=p>})</span>
</span></span></code></pre></div><h2 id=6rooms>6、Rooms<a hidden class=anchor aria-hidden=true href=#6rooms>#</a></h2><p>Flask-SocketIO通过join_room和leave_room函数支持room概念。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>flask_socketio</span> <span class=kn>import</span> <span class=n>join_room</span><span class=p>,</span> <span class=n>leave_room</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@socketio.on</span><span class=p>(</span><span class=s1>&#39;join&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>on_join</span><span class=p>(</span><span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>username</span> <span class=o>=</span> <span class=n>data</span><span class=p>[</span><span class=s1>&#39;username&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>room</span> <span class=o>=</span> <span class=n>data</span><span class=p>[</span><span class=s1>&#39;room&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>join_room</span><span class=p>(</span><span class=n>room</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>send</span><span class=p>(</span><span class=n>username</span> <span class=o>+</span> <span class=s1>&#39; has entered the room.&#39;</span><span class=p>,</span> <span class=n>room</span><span class=o>=</span><span class=n>room</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@socketio.on</span><span class=p>(</span><span class=s1>&#39;leave&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>on_leave</span><span class=p>(</span><span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>username</span> <span class=o>=</span> <span class=n>data</span><span class=p>[</span><span class=s1>&#39;username&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>room</span> <span class=o>=</span> <span class=n>data</span><span class=p>[</span><span class=s1>&#39;room&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>leave_room</span><span class=p>(</span><span class=n>room</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>send</span><span class=p>(</span><span class=n>username</span> <span class=o>+</span> <span class=s1>&#39; has left the room.&#39;</span><span class=p>,</span> <span class=n>room</span><span class=o>=</span><span class=n>room</span><span class=p>)</span>
</span></span></code></pre></div><p>send和emit函数接收关键字参数room，将消息发送至连接对应room的客户端。</p><p>所有的客户端连接room时用session ID命名，可以使用request.sid获取。</p><h2 id=7连接事件>7、连接事件<a hidden class=anchor aria-hidden=true href=#7连接事件>#</a></h2><p>Flask-SocketIO也支持连接和连接断开事件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nd>@socketio.on</span><span class=p>(</span><span class=s1>&#39;connect&#39;</span><span class=p>,</span> <span class=n>namespace</span><span class=o>=</span><span class=s1>&#39;/chat&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>test_connect</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>emit</span><span class=p>(</span><span class=s1>&#39;my response&#39;</span><span class=p>,</span> <span class=p>{</span><span class=s1>&#39;data&#39;</span><span class=p>:</span> <span class=s1>&#39;Connected&#39;</span><span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@socketio.on</span><span class=p>(</span><span class=s1>&#39;disconnect&#39;</span><span class=p>,</span> <span class=n>namespace</span><span class=o>=</span><span class=s1>&#39;/chat&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>test_disconnect</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Client disconnected&#39;</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=8基于类的命名域>8、基于类的命名域<a hidden class=anchor aria-hidden=true href=#8基于类的命名域>#</a></h2><p>上面描述的是基于装饰器的处理函数，也可以使用基于类的命名域处理函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>flask_socketio</span> <span class=kn>import</span> <span class=n>Namespace</span><span class=p>,</span> <span class=n>emit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyCustomNamespace</span><span class=p>(</span><span class=n>Namespace</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>on_connect</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>on_disconnect</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>on_my_event</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>emit</span><span class=p>(</span><span class=s1>&#39;my_response&#39;</span><span class=p>,</span> <span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>socketio</span><span class=o>.</span><span class=n>on_namespace</span><span class=p>(</span><span class=n>MyCustomNamespace</span><span class=p>(</span><span class=s1>&#39;/test&#39;</span><span class=p>))</span>
</span></span></code></pre></div><h2 id=9错误处理>9、错误处理<a hidden class=anchor aria-hidden=true href=#9错误处理>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nd>@socketio.on_error</span><span class=p>()</span>        <span class=c1># Handles the default namespace</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>error_handler</span><span class=p>(</span><span class=n>e</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@socketio.on_error</span><span class=p>(</span><span class=s1>&#39;/chat&#39;</span><span class=p>)</span> <span class=c1># handles the &#39;/chat&#39; namespace</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>error_handler_chat</span><span class=p>(</span><span class=n>e</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@socketio.on_error_default</span>  <span class=c1># handles all namespaces without an explicit error handler</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>default_error_handler</span><span class=p>(</span><span class=n>e</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://solaim.github.io/tags/python/>Python</a></li><li><a href=https://solaim.github.io/tags/flask/>Flask</a></li><li><a href=https://solaim.github.io/tags/socketio/>SocketIO</a></li></ul><nav class=paginav><a class=prev href=https://solaim.github.io/posts/rabbitmq%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/><span class=title>« Prev</span><br><span>RabbitMQ安装和基本概念</span>
</a><a class=next href=https://solaim.github.io/posts/%E6%9C%80%E5%A5%BD%E7%9A%84%E5%91%8A%E5%88%AB/><span class=title>Next »</span><br><span>最好的告别</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://solaim.github.io/>Jerry Wang</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>