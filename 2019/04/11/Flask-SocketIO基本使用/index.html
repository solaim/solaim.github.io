<!DOCTYPE html>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0,  viewport-fit=cover" name="viewport" />
    <meta name="description" content="Flask-SocketIO基本使用" />
    <meta name="hexo-theme-A4" content="v1.7.1" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Coronarium | Drill down</title>

    
        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
    
    
<link rel="stylesheet" href="/css/ui.css">
 
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>
    
    <body>
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    
<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Coronarium</a> 
            <span class="description">专注、探索、积累</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/tags/">标签</a></li>
            
        
            
                <li><a href="/about/">关于</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            Flask-SocketIO基本使用
        </div>
      
    

    <div class="post-md">
        
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-%E5%AE%89%E8%A3%85"><span class="post-toc-text">1.安装</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="post-toc-text">2.初始化</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="post-toc-text">3.接收消息</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4%E3%80%81%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="post-toc-text">4、发送消息</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5%E3%80%81%E5%B9%BF%E6%92%AD"><span class="post-toc-text">5、广播</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6%E3%80%81Rooms"><span class="post-toc-text">6、Rooms</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7%E3%80%81%E8%BF%9E%E6%8E%A5%E4%BA%8B%E4%BB%B6"><span class="post-toc-text">7、连接事件</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8%E3%80%81%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84%E5%91%BD%E5%90%8D%E5%9F%9F"><span class="post-toc-text">8、基于类的命名域</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#9%E3%80%81%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="post-toc-text">9、错误处理</span></a></li></ol>
        
        <p>Flask-SocketIO是一个用于建立WebSocket全双工通信的Flask扩展。客户端应用可以使用任一SocketIO官方客户端库实现，或可以建立持久连接的兼容客户端实现。</p>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><blockquote>
<p>pip install flask-socketio</p>
</blockquote>
<p> Flask-SocketIO提供三种异步服务机制：</p>
<ul>
<li>eventlet：支持长轮询和websocket</li>
<li>gevent：需使用第三方库</li>
<li>Werkzeug：仅支持长轮询</li>
</ul>
<h2 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> SocketIO</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">&#x27;SECRET_KEY&#x27;</span>] = <span class="string">&#x27;secret!&#x27;</span></span><br><span class="line">socketio = SocketIO(app)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    socketio.run(app)</span><br></pre></td></tr></table></figure>

<p>应用必须给客户端返回一个html页面加载SocketIO库，并且建立连接：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> socket = io.connect(<span class="string">&#x27;http://&#x27;</span> + <span class="built_in">document</span>.domain + <span class="string">&#x27;:&#x27;</span> + location.port);</span><br><span class="line">    socket.on(<span class="string">&#x27;connect&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        socket.emit(<span class="string">&#x27;my event&#x27;</span>, &#123;<span class="attr">data</span>: <span class="string">&#x27;I\&#x27;m connected!&#x27;</span>&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-接收消息"><a href="#3-接收消息" class="headerlink" title="3.接收消息"></a>3.接收消息</h2><p>使用SocketIO时，客户端和服务端以事件的方式接收消息-事件驱动。在客户端，javascript使用回调函数。在服务端，Flask-SocketIO需要注册事件处理函数，类似于路由-视图函数机制。</p>
<p>下面的例子创建服务端无名事件处理函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on(<span class="params"><span class="string">&#x27;message&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_message</span>(<span class="params">message</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;received message: &#x27;</span> + message)</span><br></pre></td></tr></table></figure>

<p>上面的例子使用字符串消息，也可以使用json格式的消息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on(<span class="params"><span class="string">&#x27;json&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_json</span>(<span class="params">json</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;received json: &#x27;</span> + <span class="built_in">str</span>(json))</span><br></pre></td></tr></table></figure>

<p>最灵活的事件类型是使用定制事件名称。这些事件的消息数据格式可以是字符串、字节、整数或者json：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on(<span class="params"><span class="string">&#x27;my event&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span>(<span class="params">json</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;received json: &#x27;</span> + <span class="built_in">str</span>(json))</span><br></pre></td></tr></table></figure>

<p>定制的命名事件支持多参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on(<span class="params"><span class="string">&#x27;my event&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span>(<span class="params">arg1, arg2, arg3</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;received args: &#x27;</span> + arg1 + arg2 + arg3)</span><br></pre></td></tr></table></figure>

<p>命名事件是最灵活的，因为命名事件消除了包含附加元数据（描述消息类型）的需要。Flask-socketIO也支持SocketIO命名域，SocketIO命名域允许客户端复用socket（多个连接建立在同一物理socket）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on(<span class="params"><span class="string">&#x27;my event&#x27;</span>, namespace=<span class="string">&#x27;/test&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_namespace_event</span>(<span class="params">json</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;received json: &#x27;</span> + <span class="built_in">str</span>(json))</span><br></pre></td></tr></table></figure>

<p>当SocketIO没有显式指定命名域，全局命名域‘／’将会被使用。</p>
<p>当装饰器语法不太合适时，on_event方法可被使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_function_handler</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">socketio.on_event(<span class="string">&#x27;my event&#x27;</span>, my_function_handler, namespace=<span class="string">&#x27;/test&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>客户端可能请求一个承认的回调函数，该函数确认接收发送的消息。处理函数的任何返回值将会作为参数递送给客户端的回调函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@socketio.on(&#x27;my event&#x27;)</span><br><span class="line"><span class="function">def <span class="title">handle_my_custom_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    print(&#x27;received json: &#x27; + str(json))</span><br><span class="line">    return &#x27;one&#x27;, 2</span><br></pre></td></tr></table></figure>

<p>上例中，客户端回调函数将会被传递两个参数：‘one’和2。</p>
<h2 id="4、发送消息"><a href="#4、发送消息" class="headerlink" title="4、发送消息"></a>4、发送消息</h2><p>Socket IO事件处理函数可以发送回复消息至连接的客户端，方法包括send()和emit()。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> send, emit</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on(<span class="params"><span class="string">&#x27;message&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_message</span>(<span class="params">message</span>):</span></span><br><span class="line">    send(message)</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on(<span class="params"><span class="string">&#x27;json&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_json</span>(<span class="params">json</span>):</span></span><br><span class="line">    send(json, json=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on(<span class="params"><span class="string">&#x27;my event&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span>(<span class="params">json</span>):</span></span><br><span class="line">    emit(<span class="string">&#x27;my response&#x27;</span>, json)</span><br></pre></td></tr></table></figure>

<p>当使用命名域时，send和emit默认使用接收消息的命名域。不同的命名域可以通过namespace参数指定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on(<span class="params"><span class="string">&#x27;message&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_message</span>(<span class="params">message</span>):</span></span><br><span class="line">    send(message, namespace=<span class="string">&#x27;/chat&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on(<span class="params"><span class="string">&#x27;my event&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span>(<span class="params">json</span>):</span></span><br><span class="line">    emit(<span class="string">&#x27;my response&#x27;</span>, json, namespace=<span class="string">&#x27;/chat&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>当使用多个参数回复一个事件时，发送一个tuple：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on(<span class="params"><span class="string">&#x27;my event&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span>(<span class="params">json</span>):</span></span><br><span class="line">    emit(<span class="string">&#x27;my response&#x27;</span>, (<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, json), namespace=<span class="string">&#x27;/chat&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>SocketIO支持回调函数，该函数用于证实客户端成功接收了消息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ack</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;message was received!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on(<span class="params"><span class="string">&#x27;my event&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span>(<span class="params">json</span>):</span></span><br><span class="line">    emit(<span class="string">&#x27;my response&#x27;</span>, json, callback=ack)</span><br></pre></td></tr></table></figure>

<p>当使用回调函数时，js客户端从接收的消息中获取回调函数，客户端回调函数唤起之后服务端的回调函数相应地被唤起。如歌客户端回调函数具有参数，服务端的回调函数具有相同的参数。</p>
<h2 id="5、广播"><a href="#5、广播" class="headerlink" title="5、广播"></a>5、广播</h2><p>Flask-SocketIO支持广播，只需在send和emit函数中添加关键字参数broadcast=True：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on(<span class="params"><span class="string">&#x27;my event&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span>(<span class="params">data</span>):</span></span><br><span class="line">    emit(<span class="string">&#x27;my response&#x27;</span>, data, broadcast=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>对于服务端主动发起的广播，socketio.send()和socketio.emit()方法可以用来广播消息至所有连接的客户端。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_function</span>():</span></span><br><span class="line">    socketio.emit(<span class="string">&#x27;some event&#x27;</span>, &#123;<span class="string">&#x27;data&#x27;</span>: <span class="number">42</span>&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="6、Rooms"><a href="#6、Rooms" class="headerlink" title="6、Rooms"></a>6、Rooms</h2><p>Flask-SocketIO通过join_room和leave_room函数支持room概念。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> join_room, leave_room</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on(<span class="params"><span class="string">&#x27;join&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_join</span>(<span class="params">data</span>):</span></span><br><span class="line">    username = data[<span class="string">&#x27;username&#x27;</span>]</span><br><span class="line">    room = data[<span class="string">&#x27;room&#x27;</span>]</span><br><span class="line">    join_room(room)</span><br><span class="line">    send(username + <span class="string">&#x27; has entered the room.&#x27;</span>, room=room)</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on(<span class="params"><span class="string">&#x27;leave&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_leave</span>(<span class="params">data</span>):</span></span><br><span class="line">    username = data[<span class="string">&#x27;username&#x27;</span>]</span><br><span class="line">    room = data[<span class="string">&#x27;room&#x27;</span>]</span><br><span class="line">    leave_room(room)</span><br><span class="line">    send(username + <span class="string">&#x27; has left the room.&#x27;</span>, room=room)</span><br></pre></td></tr></table></figure>

<p>send和emit函数接收关键字参数room，将消息发送至连接对应room的客户端。</p>
<p>所有的客户端连接room时用session ID命名，可以使用request.sid获取。</p>
<h2 id="7、连接事件"><a href="#7、连接事件" class="headerlink" title="7、连接事件"></a>7、连接事件</h2><p>Flask-SocketIO也支持连接和连接断开事件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on(<span class="params"><span class="string">&#x27;connect&#x27;</span>, namespace=<span class="string">&#x27;/chat&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_connect</span>():</span></span><br><span class="line">    emit(<span class="string">&#x27;my response&#x27;</span>, &#123;<span class="string">&#x27;data&#x27;</span>: <span class="string">&#x27;Connected&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on(<span class="params"><span class="string">&#x27;disconnect&#x27;</span>, namespace=<span class="string">&#x27;/chat&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_disconnect</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;Client disconnected&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="8、基于类的命名域"><a href="#8、基于类的命名域" class="headerlink" title="8、基于类的命名域"></a>8、基于类的命名域</h2><p>上面描述的是基于装饰器的处理函数，也可以使用基于类的命名域处理函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> Namespace, emit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomNamespace</span>(<span class="params">Namespace</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_connect</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_disconnect</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_my_event</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        emit(<span class="string">&#x27;my_response&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line">socketio.on_namespace(MyCustomNamespace(<span class="string">&#x27;/test&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="9、错误处理"><a href="#9、错误处理" class="headerlink" title="9、错误处理"></a>9、错误处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on_error()        </span><span class="comment"># Handles the default namespace</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_handler</span>(<span class="params">e</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on_error(<span class="params"><span class="string">&#x27;/chat&#x27;</span></span>) </span><span class="comment"># handles the &#x27;/chat&#x27; namespace</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_handler_chat</span>(<span class="params">e</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on_error_default  </span><span class="comment"># handles all namespaces without an explicit error handler</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">default_error_handler</span>(<span class="params">e</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>


    </div>

    <div class="post-meta">
        <i>
        
            <span>2019-04-11</span>
            
                <span>该篇文章被 Bray Wang</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/Python-Flask-SocketIO/'>
                            Python, Flask, SocketIO
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/Python/'>
                            Python
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    
        

     
</div>



                    
                    
                    <div class="footer">
    
        <span> 
            © Bray Wang 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>☀️白驹过隙,时光荏苒🌛</span>
            
                <span class="footer-last-span-right"><i>本站由<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a>驱动｜使用<a target="_blank" rel="noopener" href="https://github.com/HiNinoJay/hexo-theme-A4">Hexo-theme-A4</a>主题</i></span>
            
    
</div>


    
<link rel="stylesheet" href="/css/a11y-dark.min.css">

    
<script src="/js/highlight.min.js"></script>

    
<script src="/js/highlightjs-line-numbers.js"></script>



<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>
                </div>
            
    </body>
</html>